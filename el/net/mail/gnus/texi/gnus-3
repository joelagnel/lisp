This is gnus, produced by makeinfo version 4.8 from gnus.texi.

   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual", and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License" in the Emacs manual.

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding a
     copy of the license to the document, as described in section 6 of
     the license.

   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual", and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License" in the Emacs manual.

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding a
     copy of the license to the document, as described in section 6 of
     the license.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY


File: gnus,  Node: Agent Variables,  Next: Example Setup,  Prev: Outgoing Messages,  Up: Gnus Unplugged

6.8.10 Agent Variables
----------------------

`gnus-agent-directory'
     Where the Gnus Agent will store its files.  The default is
     `~/News/agent/'.

`gnus-agent-handle-level'
     Groups on levels (*note Group Levels::) higher than this variable
     will be ignored by the Agent.  The default is
     `gnus-level-subscribed', which means that only subscribed group
     will be considered by the Agent by default.

`gnus-agent-plugged-hook'
     Hook run when connecting to the network.

`gnus-agent-unplugged-hook'
     Hook run when disconnecting from the network.

`gnus-agent-fetched-hook'
     Hook run when finished fetching articles.

`gnus-agent-cache'
     Variable to control whether use the locally stored NOV and
     articles when plugged, e.g. essentially using the Agent as a cache.
     The default is non-`nil', which means to use the Agent as a cache.

`gnus-agent-go-online'
     If `gnus-agent-go-online' is `nil', the Agent will never
     automatically switch offline servers into online status.  If it is
     `ask', the default, the Agent will ask if you wish to switch
     offline servers into online status when you re-connect.  If it has
     any other value, all offline servers will be automatically
     switched into online status.

`gnus-agent-mark-unread-after-downloaded'
     If `gnus-agent-mark-unread-after-downloaded' is non-`nil', mark
     articles as unread after downloading.  This is usually a safe
     thing to do as the newly downloaded article has obviously not been
     read.  The default is `t'.

`gnus-agent-consider-all-articles'
     If `gnus-agent-consider-all-articles' is non-`nil', the agent will
     let the agent predicate decide whether articles need to be
     downloaded or not, for all articles.  When `nil', the default, the
     agent will only let the predicate decide whether unread articles
     are downloaded or not.  If you enable this, you may also want to
     look into the agent expiry settings (*note Category Variables::),
     so that the agent doesn't download articles which the agent will
     later expire, over and over again.

`gnus-agent-max-fetch-size'
     The agent fetches articles into a temporary buffer prior to parsing
     them into individual files.  To avoid exceeding the max. buffer
     size, the agent alternates between fetching and parsing until all
     articles have been fetched.  `gnus-agent-max-fetch-size' provides
     a size limit to control how often the cycling occurs.  A large
     value improves performance.  A small value minimizes the time lost
     should the connection be lost while fetching (You may need to run
     `gnus-agent-regenerate-group' to update the group's state.
     However, all articles parsed prior to loosing the connection will
     be available while unplugged).  The default is 10M so it is
     unusual to see any cycling.

`gnus-server-unopen-status'
     Perhaps not an Agent variable, but closely related to the Agent,
     this variable says what will happen if Gnus cannot open a server.
     If the Agent is enabled, the default, `nil', makes Gnus ask the
     user whether to deny the server or whether to unplug the agent.
     If the Agent is disabled, Gnus always simply deny the server.
     Other choices for this variable include `denied' and `offline' the
     latter is only valid if the Agent is used.

`gnus-auto-goto-ignores'
     Another variable that isn't an Agent variable, yet so closely
     related that most will look for it here, this variable tells the
     summary buffer how to maneuver around undownloaded (only headers
     stored in the agent) and unfetched (neither article nor headers
     stored) articles.

     The valid values are `nil' (maneuver to any article),
     `undownloaded' (maneuvering while unplugged ignores articles that
     have not been fetched), `always-undownloaded' (maneuvering always
     ignores articles that have not been fetched), `unfetched'
     (maneuvering ignores articles whose headers have not been fetched).

`gnus-agent-auto-agentize-methods'
     If you have never used the Agent before (or more technically, if
     `~/News/agent/lib/servers' does not exist), Gnus will
     automatically agentize a few servers for you.  This variable
     control which backends should be auto-agentized.  It is typically
     only useful to agentize remote backends.  The auto-agentizing has
     the same effect as running `J a' on the servers (*note Server
     Agent Commands::).  If the file exist, you must manage the servers
     manually by adding or removing them, this variable is only
     applicable the first time you start Gnus.  The default is `(nntp
     nnimap)'.



File: gnus,  Node: Example Setup,  Next: Batching Agents,  Prev: Agent Variables,  Up: Gnus Unplugged

6.8.11 Example Setup
--------------------

If you don't want to read this manual, and you have a fairly standard
setup, you may be able to use something like the following as your
`~/.gnus.el' file to get started.

     ;;; Define how Gnus is to fetch news.  We do this over NNTP
     ;;; from your ISP's server.
     (setq gnus-select-method '(nntp "news.your-isp.com"))

     ;;; Define how Gnus is to read your mail.  We read mail from
     ;;; your ISP's POP server.
     (setq mail-sources '((pop :server "pop.your-isp.com")))

     ;;; Say how Gnus is to store the mail.  We use nnml groups.
     (setq gnus-secondary-select-methods '((nnml "")))

     ;;; Make Gnus into an offline newsreader.
     ;;; (gnus-agentize) ; The obsolete setting.
     ;;; (setq gnus-agent t) ; Now the default.

   That should be it, basically.  Put that in your `~/.gnus.el' file,
edit to suit your needs, start up PPP (or whatever), and type `M-x
gnus'.

   If this is the first time you've run Gnus, you will be subscribed
automatically to a few default newsgroups.  You'll probably want to
subscribe to more groups, and to do that, you have to query the NNTP
server for a complete list of groups with the `A A' command.  This
usually takes quite a while, but you only have to do it once.

   After reading and parsing a while, you'll be presented with a list of
groups.  Subscribe to the ones you want to read with the `u' command.
`l' to make all the killed groups disappear after you've subscribe to
all the groups you want to read.  (`A k' will bring back all the killed
groups.)

   You can now read the groups at once, or you can download the articles
with the `J s' command.  And then read the rest of this manual to find
out which of the other gazillion things you want to customize.


File: gnus,  Node: Batching Agents,  Next: Agent Caveats,  Prev: Example Setup,  Up: Gnus Unplugged

6.8.12 Batching Agents
----------------------

Having the Gnus Agent fetch articles (and post whatever messages you've
written) is quite easy once you've gotten things set up properly.  The
following shell script will do everything that is necessary:

   You can run a complete batch command from the command line with the
following incantation:

     #!/bin/sh
     emacs -batch -l ~/.emacs -l ~/.gnus.el gnus-agent-batch >/dev/null 2>&1


File: gnus,  Node: Agent Caveats,  Prev: Batching Agents,  Up: Gnus Unplugged

6.8.13 Agent Caveats
--------------------

The Gnus Agent doesn't seem to work like most other offline
newsreaders.  Here are some common questions that some imaginary people
may ask:

"If I read an article while plugged, do they get entered into the Agent?"
     *No*.  If you want this behavior, add
     `gnus-agent-fetch-selected-article' to `gnus-select-article-hook'.

"If I read an article while plugged, and the article already exists in"
     the Agent, will it get downloaded once more?

     *No*, unless `gnus-agent-cache' is `nil'.


   In short, when Gnus is unplugged, it only looks into the locally
stored articles; when it's plugged, it talks to your ISP and may also
use the locally stored articles.


File: gnus,  Node: Scoring,  Next: Various,  Prev: Select Methods,  Up: Top

7 Scoring
*********

Other people use "kill files", but we here at Gnus Towers like scoring
better than killing, so we'd rather switch than fight.  They do
something completely different as well, so sit up straight and pay
attention!

   All articles have a default score (`gnus-summary-default-score'),
which is 0 by default.  This score may be raised or lowered either
interactively or by score files.  Articles that have a score lower than
`gnus-summary-mark-below' are marked as read.

   Gnus will read any "score files" that apply to the current group
before generating the summary buffer.

   There are several commands in the summary buffer that insert score
entries based on the current article.  You can, for instance, ask Gnus
to lower or increase the score of all articles with a certain subject.

   There are two sorts of scoring entries: Permanent and temporary.
Temporary score entries are self-expiring entries.  Any entries that are
temporary and have not been used for, say, a week, will be removed
silently to help keep the sizes of the score files down.

* Menu:

* Summary Score Commands::      Adding score entries for the current group.
* Group Score Commands::        General score commands.
* Score Variables::             Customize your scoring.  (My, what terminology).
* Score File Format::           What a score file may contain.
* Score File Editing::          You can edit score files by hand as well.
* Adaptive Scoring::            Big Sister Gnus knows what you read.
* Home Score File::             How to say where new score entries are to go.
* Followups To Yourself::       Having Gnus notice when people answer you.
* Scoring On Other Headers::    Scoring on non-standard headers.
* Scoring Tips::                How to score effectively.
* Reverse Scoring::             That problem child of old is not problem.
* Global Score Files::          Earth-spanning, ear-splitting score files.
* Kill Files::                  They are still here, but they can be ignored.
* Converting Kill Files::       Translating kill files to score files.
* GroupLens::                   Getting predictions on what you like to read.
* Advanced Scoring::            Using logical expressions to build score rules.
* Score Decays::                It can be useful to let scores wither away.


File: gnus,  Node: Summary Score Commands,  Next: Group Score Commands,  Up: Scoring

7.1 Summary Score Commands
==========================

The score commands that alter score entries do not actually modify real
score files.  That would be too inefficient.  Gnus maintains a cache of
previously loaded score files, one of which is considered the "current
score file alist".  The score commands simply insert entries into this
list, and upon group exit, this list is saved.

   The current score file is by default the group's local score file,
even if no such score file actually exists.  To insert score commands
into some other score file (e.g. `all.SCORE'), you must first make this
score file the current one.

   General score commands that don't actually change the score file:

`V s'
     Set the score of the current article (`gnus-summary-set-score').

`V S'
     Display the score of the current article
     (`gnus-summary-current-score').

`V t'
     Display all score rules that have been used on the current article
     (`gnus-score-find-trace').  In the `*Score Trace*' buffer, you may
     type `e' to edit score file corresponding to the score rule on
     current line and `f' to format (`gnus-score-pretty-print') the
     score file and edit it.

`V w'
     List words used in scoring (`gnus-score-find-favourite-words').

`V R'
     Run the current summary through the scoring process
     (`gnus-summary-rescore').  This might be useful if you're playing
     around with your score files behind Gnus' back and want to see the
     effect you're having.

`V c'
     Make a different score file the current
     (`gnus-score-change-score-file').

`V e'
     Edit the current score file (`gnus-score-edit-current-scores').
     You will be popped into a `gnus-score-mode' buffer (*note Score
     File Editing::).

`V f'
     Edit a score file and make this score file the current one
     (`gnus-score-edit-file').

`V F'
     Flush the score cache (`gnus-score-flush-cache').  This is useful
     after editing score files.

`V C'
     Customize a score file in a visually pleasing manner
     (`gnus-score-customize').


   The rest of these commands modify the local score file.

`V m'
     Prompt for a score, and mark all articles with a score below this
     as read (`gnus-score-set-mark-below').

`V x'
     Prompt for a score, and add a score rule to the current score file
     to expunge all articles below this score
     (`gnus-score-set-expunge-below').

   The keystrokes for actually making score entries follow a very
regular pattern, so there's no need to list all the commands.
(Hundreds of them.)

  1. The first key is either `I' (upper case i) for increasing the score
     or `L' for lowering the score.

  2. The second key says what header you want to score on.  The
     following keys are available:
    `a'
          Score on the author name.

    `s'
          Score on the subject line.

    `x'
          Score on the `Xref' line--i.e., the cross-posting line.

    `r'
          Score on the `References' line.

    `d'
          Score on the date.

    `l'
          Score on the number of lines.

    `i'
          Score on the `Message-ID' header.

    `e'
          Score on an "extra" header, that is, one of those in
          gnus-extra-headers, if your NNTP server tracks additional
          header data in overviews.

    `f'
          Score on followups--this matches the author name, and adds
          scores to the followups to this author.  (Using this key
          leads to the creation of `ADAPT' files.)

    `b'
          Score on the body.

    `h'
          Score on the head.

    `t'
          Score on thread.  (Using this key leads to the creation of
          `ADAPT' files.)


  3. The third key is the match type.  Which match types are valid
     depends on what headers you are scoring on.

    `strings'

         `e'
               Exact matching.

         `s'
               Substring matching.

         `f'
               Fuzzy matching (*note Fuzzy Matching::).

         `r'
               Regexp matching

    `date'

         `b'
               Before date.

         `a'
               After date.

         `n'
               This date.

    `number'

         `<'
               Less than number.

         `='
               Equal to number.

         `>'
               Greater than number.

  4. The fourth and usually final key says whether this is a temporary
     (i.e., expiring) score entry, or a permanent (i.e., non-expiring)
     score entry, or whether it is to be done immediately, without
     adding to the score file.
    `t'
          Temporary score entry.

    `p'
          Permanent score entry.

    `i'
          Immediately scoring.

  5. If you are scoring on `e' (extra) headers, you will then be
     prompted for the header name on which you wish to score.  This
     must be a header named in gnus-extra-headers, and `TAB' completion
     is available.


   So, let's say you want to increase the score on the current author
with exact matching permanently: `I a e p'.  If you want to lower the
score based on the subject line, using substring matching, and make a
temporary score entry: `L s s t'.  Pretty easy.

   To make things a bit more complicated, there are shortcuts.  If you
use a capital letter on either the second or third keys, Gnus will use
defaults for the remaining one or two keystrokes.  The defaults are
"substring" and "temporary".  So `I A' is the same as `I a s t', and `I
a R' is the same as `I a r t'.

   These functions take both the numerical prefix and the symbolic
prefix (*note Symbolic Prefixes::).  A numerical prefix says how much
to lower (or increase) the score of the article.  A symbolic prefix of
`a' says to use the `all.SCORE' file for the command instead of the
current score file.

   The `gnus-score-mimic-keymap' says whether these commands will
pretend they are keymaps or not.


File: gnus,  Node: Group Score Commands,  Next: Score Variables,  Prev: Summary Score Commands,  Up: Scoring

7.2 Group Score Commands
========================

There aren't many of these as yet, I'm afraid.

`W f'
     Gnus maintains a cache of score alists to avoid having to reload
     them all the time.  This command will flush the cache
     (`gnus-score-flush-cache').


   You can do scoring from the command line by saying something like:

     $ emacs -batch -l ~/.emacs -l ~/.gnus.el -f gnus-batch-score


File: gnus,  Node: Score Variables,  Next: Score File Format,  Prev: Group Score Commands,  Up: Scoring

7.3 Score Variables
===================

`gnus-use-scoring'
     If `nil', Gnus will not check for score files, and will not, in
     general, do any score-related work.  This is `t' by default.

`gnus-kill-killed'
     If this variable is `nil', Gnus will never apply score files to
     articles that have already been through the kill process.  While
     this may save you lots of time, it also means that if you apply a
     kill file to a group, and then change the kill file and want to
     run it over you group again to kill more articles, it won't work.
     You have to set this variable to `t' to do that.  (It is `t' by
     default.)

`gnus-kill-files-directory'
     All kill and score files will be stored in this directory, which is
     initialized from the `SAVEDIR' environment variable by default.
     This is `~/News/' by default.

`gnus-score-file-suffix'
     Suffix to add to the group name to arrive at the score file name
     (`SCORE' by default.)

`gnus-score-uncacheable-files'
     All score files are normally cached to avoid excessive re-loading
     of score files.  However, if this might make your Emacs grow big
     and bloated, so this regexp can be used to weed out score files
     unlikely to be needed again.  It would be a bad idea to deny
     caching of `all.SCORE', while it might be a good idea to not cache
     `comp.infosystems.www.authoring.misc.ADAPT'.  In fact, this
     variable is `ADAPT$' by default, so no adaptive score files will
     be cached.

`gnus-save-score'
     If you have really complicated score files, and do lots of batch
     scoring, then you might set this variable to `t'.  This will make
     Gnus save the scores into the `.newsrc.eld' file.

     If you do not set this to `t', then manual scores (like those set
     with `V s' (`gnus-summary-set-score')) will not be preserved
     across group visits.

`gnus-score-interactive-default-score'
     Score used by all the interactive raise/lower commands to
     raise/lower score with.  Default is 1000, which may seem
     excessive, but this is to ensure that the adaptive scoring scheme
     gets enough room to play with.  We don't want the small changes
     from the adaptive scoring to overwrite manually entered data.

`gnus-summary-default-score'
     Default score of an article, which is 0 by default.

`gnus-summary-expunge-below'
     Don't display the summary lines of articles that have scores lower
     than this variable.  This is `nil' by default, which means that no
     articles will be hidden.  This variable is local to the summary
     buffers, and has to be set from `gnus-summary-mode-hook'.

`gnus-score-over-mark'
     Mark (in the third column) used for articles with a score over the
     default.  Default is `+'.

`gnus-score-below-mark'
     Mark (in the third column) used for articles with a score below the
     default.  Default is `-'.

`gnus-score-find-score-files-function'
     Function used to find score files for the current group.  This
     function is called with the name of the group as the argument.

     Predefined functions available are:
    `gnus-score-find-single'
          Only apply the group's own score file.

    `gnus-score-find-bnews'
          Apply all score files that match, using bnews syntax.  This
          is the default.  If the current group is `gnu.emacs.gnus',
          for instance, `all.emacs.all.SCORE', `not.alt.all.SCORE' and
          `gnu.all.SCORE' would all apply.  In short, the instances of
          `all' in the score file names are translated into `.*', and
          then a regexp match is done.

          This means that if you have some score entries that you want
          to apply to all groups, then you put those entries in the
          `all.SCORE' file.

          The score files are applied in a semi-random order, although
          Gnus will try to apply the more general score files before
          the more specific score files.  It does this by looking at
          the number of elements in the score file names--discarding
          the `all' elements.

    `gnus-score-find-hierarchical'
          Apply all score files from all the parent groups.  This means
          that you can't have score files like `all.SCORE', but you can
          have `SCORE', `comp.SCORE' and `comp.emacs.SCORE' for each
          server.

     This variable can also be a list of functions.  In that case, all
     these functions will be called with the group name as argument, and
     all the returned lists of score files will be applied.  These
     functions can also return lists of lists of score alists directly.
     In that case, the functions that return these non-file score
     alists should probably be placed before the "real" score file
     functions, to ensure that the last score file returned is the
     local score file.  Phu.

     For example, to do hierarchical scoring but use a
     non-server-specific overall score file, you could use the value
          (list (lambda (group) ("all.SCORE"))
                'gnus-score-find-hierarchical)

`gnus-score-expiry-days'
     This variable says how many days should pass before an unused
     score file entry is expired.  If this variable is `nil', no score
     file entries are expired.  It's 7 by default.

`gnus-update-score-entry-dates'
     If this variable is non-`nil', temporary score entries that have
     been triggered (matched) will have their dates updated.  (This is
     how Gnus controls expiry--all non-matched-entries will become too
     old while matched entries will stay fresh and young.)  However, if
     you set this variable to `nil', even matched entries will grow old
     and will have to face that oh-so grim reaper.

`gnus-score-after-write-file-function'
     Function called with the name of the score file just written.

`gnus-score-thread-simplify'
     If this variable is non-`nil', article subjects will be simplified
     for subject scoring purposes in the same manner as with
     threading--according to the current value of
     `gnus-simplify-subject-functions'.  If the scoring entry uses
     `substring' or `exact' matching, the match will also be simplified
     in this manner.



File: gnus,  Node: Score File Format,  Next: Score File Editing,  Prev: Score Variables,  Up: Scoring

7.4 Score File Format
=====================

A score file is an `emacs-lisp' file that normally contains just a
single form.  Casual users are not expected to edit these files;
everything can be changed from the summary buffer.

   Anyway, if you'd like to dig into it yourself, here's an example:

     (("from"
       ("Lars Ingebrigtsen" -10000)
       ("Per Abrahamsen")
       ("larsi\\|lmi" -50000 nil R))
      ("subject"
       ("Ding is Badd" nil 728373))
      ("xref"
       ("alt.politics" -1000 728372 s))
      ("lines"
       (2 -100 nil <))
      (mark 0)
      (expunge -1000)
      (mark-and-expunge -10)
      (read-only nil)
      (orphan -10)
      (adapt t)
      (files "/hom/larsi/News/gnu.SCORE")
      (exclude-files "all.SCORE")
      (local (gnus-newsgroup-auto-expire t)
             (gnus-summary-make-false-root empty))
      (eval (ding)))

   This example demonstrates most score file elements.  *Note Advanced
Scoring::, for a different approach.

   Even though this looks much like Lisp code, nothing here is actually
`eval'ed.  The Lisp reader is used to read this form, though, so it has
to be valid syntactically, if not semantically.

   Six keys are supported by this alist:

`STRING'
     If the key is a string, it is the name of the header to perform the
     match on.  Scoring can only be performed on these eight headers:
     `From', `Subject', `References', `Message-ID', `Xref', `Lines',
     `Chars' and `Date'.  In addition to these headers, there are three
     strings to tell Gnus to fetch the entire article and do the match
     on larger parts of the article: `Body' will perform the match on
     the body of the article, `Head' will perform the match on the head
     of the article, and `All' will perform the match on the entire
     article.  Note that using any of these last three keys will slow
     down group entry _considerably_.  The final "header" you can score
     on is `Followup'.  These score entries will result in new score
     entries being added for all follow-ups to articles that matches
     these score entries.

     Following this key is an arbitrary number of score entries, where
     each score entry has one to four elements.
       1. The first element is the "match element".  On most headers
          this will be a string, but on the Lines and Chars headers,
          this must be an integer.

       2. If the second element is present, it should be a number--the
          "score element".  This number should be an integer in the
          neginf to posinf interval.  This number is added to the score
          of the article if the match is successful.  If this element
          is not present, the `gnus-score-interactive-default-score'
          number will be used instead.  This is 1000 by default.

       3. If the third element is present, it should be a number--the
          "date element".  This date says when the last time this score
          entry matched, which provides a mechanism for expiring the
          score entries.  It this element is not present, the score
          entry is permanent.  The date is represented by the number of
          days since December 31, 1 BCE.

       4. If the fourth element is present, it should be a symbol--the
          "type element".  This element specifies what function should
          be used to see whether this score entry matches the article.
          What match types that can be used depends on what header you
          wish to perform the match on.
         "From, Subject, References, Xref, Message-ID"
               For most header types, there are the `r' and `R'
               (regexp), as well as `s' and `S' (substring) types, and
               `e' and `E' (exact match), and `w' (word match) types.
               If this element is not present, Gnus will assume that
               substring matching should be used.  `R', `S', and `E'
               differ from the others in that the matches will be done
               in a case-sensitive manner.  All these one-letter types
               are really just abbreviations for the `regexp',
               `string', `exact', and `word' types, which you can use
               instead, if you feel like.

         "Extra"
               Just as for the standard string overview headers, if you
               are using gnus-extra-headers, you can score on these
               headers' values.  In this case, there is a 5th element
               in the score entry, being the name of the header to be
               scored.  The following entry is useful in your
               `all.SCORE' file in case of spam attacks from a single
               origin host, if your NNTP server tracks
               `NNTP-Posting-Host' in overviews:

                    ("111.222.333.444" -1000 nil s
                     "NNTP-Posting-Host")

         "Lines, Chars"
               These two headers use different match types: `<', `>',
               `=', `>=' and `<='.

               These predicates are true if

                    (PREDICATE HEADER MATCH)

               evaluates to non-`nil'.  For instance, the advanced match
               `("lines" 4 <)' (*note Advanced Scoring::) will result
               in the following form:

                    (< header-value 4)

               Or to put it another way: When using `<' on `Lines' with
               4 as the match, we get the score added if the article
               has less than 4 lines.  (It's easy to get confused and
               think it's the other way around.  But it's not.  I
               think.)

               When matching on `Lines', be careful because some back
               ends (like `nndir') do not generate `Lines' header, so
               every article ends up being marked as having 0 lines.
               This can lead to strange results if you happen to lower
               score of the articles with few lines.

         "Date"
               For the Date header we have three kinda silly match
               types: `before', `at' and `after'.  I can't really
               imagine this ever being useful, but, like, it would feel
               kinda silly not to provide this function.  Just in case.
               You never know.  Better safe than sorry.  Once burnt,
               twice shy.  Don't judge a book by its cover.  Never not
               have sex on a first date.  (I have been told that at
               least one person, and I quote, "found this function
               indispensable", however.)

               A more useful match type is `regexp'.  With it, you can
               match the date string using a regular expression.  The
               date is normalized to ISO8601 compact format
               first--YYYYMMDD`T'HHMMSS.  If you want to match all
               articles that have been posted on April 1st in every
               year, you could use `....0401.........' as a match
               string, for instance.  (Note that the date is kept in
               its original time zone, so this will match articles that
               were posted when it was April 1st where the article was
               posted from.  Time zones are such wholesome fun for the
               whole family, eh?)

         "Head, Body, All"
               These three match keys use the same match types as the
               `From' (etc) header uses.

         "Followup"
               This match key is somewhat special, in that it will
               match the `From' header, and affect the score of not
               only the matching articles, but also all followups to
               the matching articles.  This allows you e.g. increase
               the score of followups to your own articles, or decrease
               the score of followups to the articles of some known
               trouble-maker.  Uses the same match types as the `From'
               header uses.  (Using this match key will lead to
               creation of `ADAPT' files.)

         "Thread"
               This match key works along the same lines as the
               `Followup' match key.  If you say that you want to score
               on a (sub-)thread started by an article with a
               `Message-ID' X, then you add a `thread' match.  This
               will add a new `thread' match for each article that has
               X in its `References' header.  (These new `thread'
               matches will use the `Message-ID's of these matching
               articles.)  This will ensure that you can raise/lower
               the score of an entire thread, even though some articles
               in the thread may not have complete `References'
               headers.  Note that using this may lead to
               undeterministic scores of the articles in the thread.
               (Using this match key will lead to creation of `ADAPT'
               files.)

`mark'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read.

`expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be removed from the summary
     buffer.

`mark-and-expunge'
     The value of this entry should be a number.  Any articles with a
     score lower than this number will be marked as read and removed
     from the summary buffer.

`thread-mark-and-expunge'
     The value of this entry should be a number.  All articles that
     belong to a thread that has a total score below this number will
     be marked as read and removed from the summary buffer.
     `gnus-thread-score-function' says how to compute the total score
     for a thread.

`files'
     The value of this entry should be any number of file names.  These
     files are assumed to be score files as well, and will be loaded
     the same way this one was.

`exclude-files'
     The clue of this entry should be any number of files.  These files
     will not be loaded, even though they would normally be so, for
     some reason or other.

`eval'
     The value of this entry will be `eval'el.  This element will be
     ignored when handling global score files.

`read-only'
     Read-only score files will not be updated or saved.  Global score
     files should feature this atom (*note Global Score Files::).
     (Note: "Global" here really means "global"; not your personal
     apply-to-all-groups score files.)

`orphan'
     The value of this entry should be a number.  Articles that do not
     have parents will get this number added to their scores.  Imagine
     you follow some high-volume newsgroup, like `comp.lang.c'.  Most
     likely you will only follow a few of the threads, also want to see
     any new threads.

     You can do this with the following two score file entries:

                  (orphan -500)
                  (mark-and-expunge -100)

     When you enter the group the first time, you will only see the new
     threads.  You then raise the score of the threads that you find
     interesting (with `I T' or `I S'), and ignore (`C y') the rest.
     Next time you enter the group, you will see new articles in the
     interesting threads, plus any new threads.

     I.e.--the orphan score atom is for high-volume groups where a few
     interesting threads which can't be found automatically by ordinary
     scoring rules exist.

`adapt'
     This entry controls the adaptive scoring.  If it is `t', the
     default adaptive scoring rules will be used.  If it is `ignore', no
     adaptive scoring will be performed on this group.  If it is a
     list, this list will be used as the adaptive scoring rules.  If it
     isn't present, or is something other than `t' or `ignore', the
     default adaptive scoring rules will be used.  If you want to use
     adaptive scoring on most groups, you'd set
     `gnus-use-adaptive-scoring' to `t', and insert an `(adapt ignore)'
     in the groups where you do not want adaptive scoring.  If you only
     want adaptive scoring in a few groups, you'd set
     `gnus-use-adaptive-scoring' to `nil', and insert `(adapt t)' in
     the score files of the groups where you want it.

`adapt-file'
     All adaptive score entries will go to the file named by this
     entry.  It will also be applied when entering the group.  This
     atom might be handy if you want to adapt on several groups at
     once, using the same adaptive file for a number of groups.

`local'
     The value of this entry should be a list of `(VAR VALUE)' pairs.
     Each VAR will be made buffer-local to the current summary buffer,
     and set to the value specified.  This is a convenient, if somewhat
     strange, way of setting variables in some groups if you don't like
     hooks much.  Note that the VALUE won't be evaluated.


File: gnus,  Node: Score File Editing,  Next: Adaptive Scoring,  Prev: Score File Format,  Up: Scoring

7.5 Score File Editing
======================

You normally enter all scoring commands from the summary buffer, but you
might feel the urge to edit them by hand as well, so we've supplied you
with a mode for that.

   It's simply a slightly customized `emacs-lisp' mode, with these
additional commands:

`C-c C-c'
     Save the changes you have made and return to the summary buffer
     (`gnus-score-edit-done').

`C-c C-d'
     Insert the current date in numerical format
     (`gnus-score-edit-insert-date').  This is really the day number, if
     you were wondering.

`C-c C-p'
     The adaptive score files are saved in an unformatted fashion.  If
     you intend to read one of these files, you want to "pretty print"
     it first.  This command (`gnus-score-pretty-print') does that for
     you.


   Type `M-x gnus-score-mode' to use this mode.

   `gnus-score-menu-hook' is run in score mode buffers.

   In the summary buffer you can use commands like `V f', `V e' and `V
t' to begin editing score files.


File: gnus,  Node: Adaptive Scoring,  Next: Home Score File,  Prev: Score File Editing,  Up: Scoring

7.6 Adaptive Scoring
====================

If all this scoring is getting you down, Gnus has a way of making it all
happen automatically--as if by magic.  Or rather, as if by artificial
stupidity, to be precise.

   When you read an article, or mark an article as read, or kill an
article, you leave marks behind.  On exit from the group, Gnus can sniff
these marks and add score elements depending on what marks it finds.
You turn on this ability by setting `gnus-use-adaptive-scoring' to `t'
or `(line)'.  If you want score adaptively on separate words appearing
in the subjects, you should set this variable to `(word)'.  If you want
to use both adaptive methods, set this variable to `(word line)'.

   To give you complete control over the scoring process, you can
customize the `gnus-default-adaptive-score-alist' variable.  For
instance, it might look something like this:

     (setq gnus-default-adaptive-score-alist
       '((gnus-unread-mark)
         (gnus-ticked-mark (from 4))
         (gnus-dormant-mark (from 5))
         (gnus-del-mark (from -4) (subject -1))
         (gnus-read-mark (from 4) (subject 2))
         (gnus-expirable-mark (from -1) (subject -1))
         (gnus-killed-mark (from -1) (subject -3))
         (gnus-kill-file-mark)
         (gnus-ancient-mark)
         (gnus-low-score-mark)
         (gnus-catchup-mark (from -1) (subject -1))))

   As you see, each element in this alist has a mark as a key (either a
variable name or a "real" mark--a character).  Following this key is a
arbitrary number of header/score pairs.  If there are no header/score
pairs following the key, no adaptive scoring will be done on articles
that have that key as the article mark.  For instance, articles with
`gnus-unread-mark' in the example above will not get adaptive score
entries.

   Each article can have only one mark, so just a single of these rules
will be applied to each article.

   To take `gnus-del-mark' as an example--this alist says that all
articles that have that mark (i.e., are marked with `e') will have a
score entry added to lower based on the `From' header by -4, and
lowered by `Subject' by -1.  Change this to fit your prejudices.

   If you have marked 10 articles with the same subject with
`gnus-del-mark', the rule for that mark will be applied ten times.
That means that that subject will get a score of ten times -1, which
should be, unless I'm much mistaken, -10.

   If you have auto-expirable (mail) groups (*note Expiring Mail::), all
the read articles will be marked with the `E' mark.  This'll probably
make adaptive scoring slightly impossible, so auto-expiring and
adaptive scoring doesn't really mix very well.

   The headers you can score on are `from', `subject', `message-id',
`references', `xref', `lines', `chars' and `date'.  In addition, you
can score on `followup', which will create an adaptive score entry that
matches on the `References' header using the `Message-ID' of the
current article, thereby matching the following thread.

   If you use this scheme, you should set the score file atom `mark' to
something small--like -300, perhaps, to avoid having small random
changes result in articles getting marked as read.

   After using adaptive scoring for a week or so, Gnus should start to
become properly trained and enhance the authors you like best, and kill
the authors you like least, without you having to say so explicitly.

   You can control what groups the adaptive scoring is to be performed
on by using the score files (*note Score File Format::).  This will also
let you use different rules in different groups.

   The adaptive score entries will be put into a file where the name is
the group name with `gnus-adaptive-file-suffix' appended.  The default
is `ADAPT'.

   When doing adaptive scoring, substring or fuzzy matching would
probably give you the best results in most cases.  However, if the
header one matches is short, the possibility for false positives is
great, so if the length of the match is less than
`gnus-score-exact-adapt-limit', exact matching will be used.  If this
variable is `nil', exact matching will always be used to avoid this
problem.

   As mentioned above, you can adapt either on individual words or
entire headers.  If you adapt on words, the
`gnus-default-adaptive-word-score-alist' variable says what score each
instance of a word should add given a mark.

     (setq gnus-default-adaptive-word-score-alist
           `((,gnus-read-mark . 30)
             (,gnus-catchup-mark . -10)
             (,gnus-killed-mark . -20)
             (,gnus-del-mark . -15)))

   This is the default value.  If you have adaption on words enabled,
every word that appears in subjects of articles marked with
`gnus-read-mark' will result in a score rule that increase the score
with 30 points.

   Words that appear in the `gnus-default-ignored-adaptive-words' list
will be ignored.  If you wish to add more words to be ignored, use the
`gnus-ignored-adaptive-words' list instead.

   Some may feel that short words shouldn't count when doing adaptive
scoring.  If so, you may set `gnus-adaptive-word-length-limit' to an
integer.  Words shorter than this number will be ignored.  This
variable defaults to `nil'.

   When the scoring is done, `gnus-adaptive-word-syntax-table' is the
syntax table in effect.  It is similar to the standard syntax table, but
it considers numbers to be non-word-constituent characters.

   If `gnus-adaptive-word-minimum' is set to a number, the adaptive
word scoring process will never bring down the score of an article to
below this number.  The default is `nil'.

   If `gnus-adaptive-word-no-group-words' is set to `t', gnus won't
adaptively word score any of the words in the group name.  Useful for
groups like `comp.editors.emacs', where most of the subject lines
contain the word `emacs'.

   After using this scheme for a while, it might be nice to write a
`gnus-psychoanalyze-user' command to go through the rules and see what
words you like and what words you don't like.  Or perhaps not.

   Note that the adaptive word scoring thing is highly experimental and
is likely to change in the future.  Initial impressions seem to indicate
that it's totally useless as it stands.  Some more work (involving more
rigorous statistical methods) will have to be done to make this useful.


File: gnus,  Node: Home Score File,  Next: Followups To Yourself,  Prev: Adaptive Scoring,  Up: Scoring

7.7 Home Score File
===================

The score file where new score file entries will go is called the "home
score file".  This is normally (and by default) the score file for the
group itself.  For instance, the home score file for `gnu.emacs.gnus'
is `gnu.emacs.gnus.SCORE'.

   However, this may not be what you want.  It is often convenient to
share a common home score file among many groups--all `emacs' groups
could perhaps use the same home score file.

   The variable that controls this is `gnus-home-score-file'.  It can
be:

  1. A string.  Then this file will be used as the home score file for
     all groups.

  2. A function.  The result of this function will be used as the home
     score file.  The function will be called with the name of the
     group as the parameter.

  3. A list.  The elements in this list can be:

       1. `(REGEXP FILE-NAME)'.  If the REGEXP matches the group name,
          the FILE-NAME will be used as the home score file.

       2. A function.  If the function returns non-`nil', the result
          will be used as the home score file.  The function will be
          called with the name of the group as the parameter.

       3. A string.  Use the string as the home score file.

     The list will be traversed from the beginning towards the end
     looking for matches.


   So, if you want to use just a single score file, you could say:

     (setq gnus-home-score-file
           "my-total-score-file.SCORE")

   If you want to use `gnu.SCORE' for all `gnu' groups and `rec.SCORE'
for all `rec' groups (and so on), you can say:

     (setq gnus-home-score-file
           'gnus-hierarchial-home-score-file)

   This is a ready-made function provided for your convenience.  Other
functions include

`gnus-current-home-score-file'
     Return the "current" regular score file.  This will make scoring
     commands add entry to the "innermost" matching score file.


   If you want to have one score file for the `emacs' groups and
another for the `comp' groups, while letting all other groups use their
own home score files:

     (setq gnus-home-score-file
           ;; All groups that match the regexp `"\\.emacs"'
           '(("\\.emacs" "emacs.SCORE")
             ;; All the comp groups in one score file
             ("^comp" "comp.SCORE")))

   `gnus-home-adapt-file' works exactly the same way as
`gnus-home-score-file', but says what the home adaptive score file is
instead.  All new adaptive file entries will go into the file specified
by this variable, and the same syntax is allowed.

   In addition to using `gnus-home-score-file' and
`gnus-home-adapt-file', you can also use group parameters (*note Group
Parameters::) and topic parameters (*note Topic Parameters::) to
achieve much the same.  Group and topic parameters take precedence over
this variable.


File: gnus,  Node: Followups To Yourself,  Next: Scoring On Other Headers,  Prev: Home Score File,  Up: Scoring

7.8 Followups To Yourself
=========================

Gnus offers two commands for picking out the `Message-ID' header in the
current buffer.  Gnus will then add a score rule that scores using this
`Message-ID' on the `References' header of other articles.  This will,
in effect, increase the score of all articles that respond to the
article in the current buffer.  Quite useful if you want to easily note
when people answer what you've said.

`gnus-score-followup-article'
     This will add a score to articles that directly follow up your own
     article.

`gnus-score-followup-thread'
     This will add a score to all articles that appear in a thread
     "below" your own article.

   These two functions are both primarily meant to be used in hooks like
`message-sent-hook', like this:
     (add-hook 'message-sent-hook 'gnus-score-followup-thread)

   If you look closely at your own `Message-ID', you'll notice that the
first two or three characters are always the same.  Here's two of mine:

     <x6u3u47icf.fsf@eyesore.no>
     <x6sp9o7ibw.fsf@eyesore.no>

   So "my" ident on this machine is `x6'.  This can be exploited--the
following rule will raise the score on all followups to myself:

     ("references"
      ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@.*eyesore\\.no>"
       1000 nil r))

   Whether it's the first two or first three characters that are "yours"
is system-dependent.


File: gnus,  Node: Scoring On Other Headers,  Next: Scoring Tips,  Prev: Followups To Yourself,  Up: Scoring

7.9 Scoring On Other Headers
============================

Gnus is quite fast when scoring the "traditional" headers--`From',
`Subject' and so on.  However, scoring other headers requires writing a
`head' scoring rule, which means that Gnus has to request every single
article from the back end to find matches.  This takes a long time in
big groups.

   Now, there's not much you can do about this for news groups, but for
mail groups, you have greater control.  In *Note To From Newsgroups::,
it's explained in greater detail what this mechanism does, but here's a
cookbook example for `nnml' on how to allow scoring on the `To' and
`Cc' headers.

   Put the following in your `~/.gnus.el' file.

     (setq gnus-extra-headers '(To Cc Newsgroups Keywords)
           nnmail-extra-headers gnus-extra-headers)

   Restart Gnus and rebuild your `nnml' overview files with the `M-x
nnml-generate-nov-databases' command.  This will take a long time if
you have much mail.

   Now you can score on `To' and `Cc' as "extra headers" like so: `I e
s p To RET <your name> RET'.

   See?  Simple.


File: gnus,  Node: Scoring Tips,  Next: Reverse Scoring,  Prev: Scoring On Other Headers,  Up: Scoring

7.10 Scoring Tips
=================

"Crossposts"
     If you want to lower the score of crossposts, the line to match on
     is the `Xref' header.
          ("xref" (" talk.politics.misc:" -1000))

"Multiple crossposts"
     If you want to lower the score of articles that have been
     crossposted to more than, say, 3 groups:
          ("xref"
            ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
             -1000 nil r))

"Matching on the body"
     This is generally not a very good idea--it takes a very long time.
     Gnus actually has to fetch each individual article from the
     server.  But you might want to anyway, I guess.  Even though there
     are three match keys (`Head', `Body' and `All'), you should choose
     one and stick with it in each score file.  If you use any two,
     each article will be fetched _twice_.  If you want to match a bit
     on the `Head' and a bit on the `Body', just use `All' for all the
     matches.

"Marking as read"
     You will probably want to mark articles that have scores below a
     certain number as read.  This is most easily achieved by putting
     the following in your `all.SCORE' file:
          ((mark -100))
     You may also consider doing something similar with `expunge'.

"Negated character classes"
     If you say stuff like `[^abcd]*', you may get unexpected results.
     That will match newlines, which might lead to, well, The Unknown.
     Say `[^abcd\n]*' instead.


File: gnus,  Node: Reverse Scoring,  Next: Global Score Files,  Prev: Scoring Tips,  Up: Scoring

7.11 Reverse Scoring
====================

If you want to keep just articles that have `Sex with Emacs' in the
subject header, and expunge all other articles, you could put something
like this in your score file:

     (("subject"
       ("Sex with Emacs" 2))
      (mark 1)
      (expunge 1))

   So, you raise all articles that match `Sex with Emacs' and mark the
rest as read, and expunge them to boot.


File: gnus,  Node: Global Score Files,  Next: Kill Files,  Prev: Reverse Scoring,  Up: Scoring

7.12 Global Score Files
=======================

Sure, other newsreaders have "global kill files".  These are usually
nothing more than a single kill file that applies to all groups, stored
in the user's home directory.  Bah!  Puny, weak newsreaders!

   What I'm talking about here are Global Score Files.  Score files from
all over the world, from users everywhere, uniting all nations in one
big, happy score file union!  Ange-score!  New and untested!

   All you have to do to use other people's score files is to set the
`gnus-global-score-files' variable.  One entry for each score file, or
each score file directory.  Gnus will decide by itself what score files
are applicable to which group.

   To use the score file
`/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE' and all score
files in the `/ftp@ftp.some-where:/pub/score' directory, say this:

     (setq gnus-global-score-files
           '("/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
             "/ftp@ftp.some-where:/pub/score/"))

Simple, eh?  Directory names must end with a `/'.  These directories
are typically scanned only once during each Gnus session.  If you feel
the need to manually re-scan the remote directories, you can use the
`gnus-score-search-global-directories' command.

   Note that, at present, using this option will slow down group entry
somewhat.  (That is--a lot.)

   If you want to start maintaining score files for other people to use,
just put your score file up for anonymous ftp and announce it to the
world.  Become a retro-moderator!  Participate in the retro-moderator
wars sure to ensue, where retro-moderators battle it out for the
sympathy of the people, luring them to use their score files on false
premises!  Yay!  The net is saved!

   Here are some tips for the would-be retro-moderator, off the top of
my head:

   * Articles heavily crossposted are probably junk.

   * To lower a single inappropriate article, lower by `Message-ID'.

   * Particularly brilliant authors can be raised on a permanent basis.

   * Authors that repeatedly post off-charter for the group can safely
     be lowered out of existence.

   * Set the `mark' and `expunge' atoms to obliterate the nastiest
     articles completely.

   * Use expiring score entries to keep the size of the file down.  You
     should probably have a long expiry period, though, as some sites
     keep old articles for a long time.

   ... I wonder whether other newsreaders will support global score
files in the future.  _Snicker_.  Yup, any day now, newsreaders like
Blue Wave, xrn and 1stReader are bound to implement scoring.  Should we
start holding our breath yet?


File: gnus,  Node: Kill Files,  Next: Converting Kill Files,  Prev: Global Score Files,  Up: Scoring

7.13 Kill Files
===============

Gnus still supports those pesky old kill files.  In fact, the kill file
entries can now be expiring, which is something I wrote before Daniel
Quinlan thought of doing score files, so I've left the code in there.

   In short, kill processing is a lot slower (and I do mean _a lot_)
than score processing, so it might be a good idea to rewrite your kill
files into score files.

   Anyway, a kill file is a normal `emacs-lisp' file.  You can put any
forms into this file, which means that you can use kill files as some
sort of primitive hook function to be run on group entry, even though
that isn't a very good idea.

   Normal kill files look like this:

     (gnus-kill "From" "Lars Ingebrigtsen")
     (gnus-kill "Subject" "ding")
     (gnus-expunge "X")

   This will mark every article written by me as read, and remove the
marked articles from the summary buffer.  Very useful, you'll agree.

   Other programs use a totally different kill file syntax.  If Gnus
encounters what looks like a `rn' kill file, it will take a stab at
interpreting it.

   Two summary functions for editing a GNUS kill file:

`M-k'
     Edit this group's kill file (`gnus-summary-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-summary-edit-global-kill').

   Two group mode functions for editing the kill files:

`M-k'
     Edit this group's kill file (`gnus-group-edit-local-kill').

`M-K'
     Edit the general kill file (`gnus-group-edit-global-kill').

   Kill file variables:

`gnus-kill-file-name'
     A kill file for the group `soc.motss' is normally called
     `soc.motss.KILL'.  The suffix appended to the group name to get
     this file name is detailed by the `gnus-kill-file-name' variable.
     The "global" kill file (not in the score file sense of "global", of
     course) is just called `KILL'.

`gnus-kill-save-kill-file'
     If this variable is non-`nil', Gnus will save the kill file after
     processing, which is necessary if you use expiring kills.

`gnus-apply-kill-hook'
     A hook called to apply kill files to a group.  It is
     `(gnus-apply-kill-file)' by default.  If you want to ignore the
     kill file if you have a score file for the same group, you can set
     this hook to `(gnus-apply-kill-file-unless-scored)'.  If you don't
     want kill files to be processed, you should set this variable to
     `nil'.

`gnus-kill-file-mode-hook'
     A hook called in kill-file mode buffers.



File: gnus,  Node: Converting Kill Files,  Next: GroupLens,  Prev: Kill Files,  Up: Scoring

7.14 Converting Kill Files
==========================

If you have loads of old kill files, you may want to convert them into
score files.  If they are "regular", you can use the
`gnus-kill-to-score.el' package; if not, you'll have to do it by hand.

   The kill to score conversion package isn't included in Gnus by
default.  You can fetch it from
`http://www.stud.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el'.

   If your old kill files are very complex--if they contain more
non-`gnus-kill' forms than not, you'll have to convert them by hand.
Or just let them be as they are.  Gnus will still use them as before.


File: gnus,  Node: GroupLens,  Next: Advanced Scoring,  Prev: Converting Kill Files,  Up: Scoring

7.15 GroupLens
==============

NOTE: Unfortunately the GroupLens system seems to have shut down, so
this section is mostly of historical interest.

   GroupLens (http://www.cs.umn.edu/Research/GroupLens/) is a
collaborative filtering system that helps you work together with other
people to find the quality news articles out of the huge volume of news
articles generated every day.

   To accomplish this the GroupLens system combines your opinions about
articles you have already read with the opinions of others who have done
likewise and gives you a personalized prediction for each unread news
article.  Think of GroupLens as a matchmaker.  GroupLens watches how you
rate articles, and finds other people that rate articles the same way.
Once it has found some people you agree with it tells you, in the form
of a prediction, what they thought of the article.  You can use this
prediction to help you decide whether or not you want to read the
article.

* Menu:

* Using GroupLens::             How to make Gnus use GroupLens.
* Rating Articles::             Letting GroupLens know how you rate articles.
* Displaying Predictions::      Displaying predictions given by GroupLens.
* GroupLens Variables::         Customizing GroupLens.


File: gnus,  Node: Using GroupLens,  Next: Rating Articles,  Up: GroupLens

7.15.1 Using GroupLens
----------------------

To use GroupLens you must register a pseudonym with your local Better
Bit Bureau (BBB) (http://www.cs.umn.edu/Research/GroupLens/bbb.html) is
the only better bit in town at the moment.

   Once you have registered you'll need to set a couple of variables.

`gnus-use-grouplens'
     Setting this variable to a non-`nil' value will make Gnus hook into
     all the relevant GroupLens functions.

`grouplens-pseudonym'
     This variable should be set to the pseudonym you got when
     registering with the Better Bit Bureau.

`grouplens-newsgroups'
     A list of groups that you want to get GroupLens predictions for.


   That's the minimum of what you need to get up and running with
GroupLens.  Once you've registered, GroupLens will start giving you
scores for articles based on the average of what other people think.
But, to get the real benefit of GroupLens you need to start rating
articles yourself.  Then the scores GroupLens gives you will be
personalized for you, based on how the people you usually agree with
have already rated.


File: gnus,  Node: Rating Articles,  Next: Displaying Predictions,  Prev: Using GroupLens,  Up: GroupLens

7.15.2 Rating Articles
----------------------

In GroupLens, an article is rated on a scale from 1 to 5, inclusive.
Where 1 means something like this article is a waste of bandwidth and 5
means that the article was really good.  The basic question to ask
yourself is, "on a scale from 1 to 5 would I like to see more articles
like this one?"

   There are four ways to enter a rating for an article in GroupLens.

`r'
     This function will prompt you for a rating on a scale of one to
     five.

`k'
     This function will prompt you for a rating, and rate all the
     articles in the thread.  This is really useful for some of those
     long running giant threads in rec.humor.


   The next two commands, `n' and `,' take a numerical prefix to be the
score of the article you're reading.

`1-5 n'
     Rate the article and go to the next unread article.

`1-5 ,'
     Rate the article and go to the next unread article with the
     highest score.


   If you want to give the current article a score of 4 and then go to
the next article, just type `4 n'.


File: gnus,  Node: Displaying Predictions,  Next: GroupLens Variables,  Prev: Rating Articles,  Up: GroupLens

7.15.3 Displaying Predictions
-----------------------------

GroupLens makes a prediction for you about how much you will like a
news article.  The predictions from GroupLens are on a scale from 1 to
5, where 1 is the worst and 5 is the best.  You can use the predictions
from GroupLens in one of three ways controlled by the variable
`gnus-grouplens-override-scoring'.

   There are three ways to display predictions in grouplens.  You may
choose to have the GroupLens scores contribute to, or override the
regular Gnus scoring mechanism.  override is the default; however, some
people prefer to see the Gnus scores plus the grouplens scores.  To get
the separate scoring behavior you need to set
`gnus-grouplens-override-scoring' to `'separate'.  To have the
GroupLens predictions combined with the grouplens scores set it to
`'override' and to combine the scores set
`gnus-grouplens-override-scoring' to `'combine'.  When you use the
combine option you will also want to set the values for
`grouplens-prediction-offset' and `grouplens-score-scale-factor'.

   In either case, GroupLens gives you a few choices for how you would
like to see your predictions displayed.  The display of predictions is
controlled by the `grouplens-prediction-display' variable.

   The following are valid values for that variable.

`prediction-spot'
     The higher the prediction, the further to the right an `*' is
     displayed.

`confidence-interval'
     A numeric confidence interval.

`prediction-bar'
     The higher the prediction, the longer the bar.

`confidence-bar'
     Numerical confidence.

`confidence-spot'
     The spot gets bigger with more confidence.

`prediction-num'
     Plain-old numeric value.

`confidence-plus-minus'
     Prediction +/- confidence.



File: gnus,  Node: GroupLens Variables,  Prev: Displaying Predictions,  Up: GroupLens

7.15.4 GroupLens Variables
--------------------------

`gnus-summary-grouplens-line-format'
     The summary line format used in GroupLens-enhanced summary
     buffers.  It accepts the same specs as the normal summary line
     format (*note Summary Buffer Lines::).  The default is
     `%U%R%z%l%I%(%[%4L: %-23,23n%]%) %s\n'.

`grouplens-bbb-host'
     Host running the bbbd server.  `grouplens.cs.umn.edu' is the
     default.

`grouplens-bbb-port'
     Port of the host running the bbbd server.  The default is 9000.

`grouplens-score-offset'
     Offset the prediction by this value.  In other words, subtract the
     prediction value by this number to arrive at the effective score.
     The default is 0.

`grouplens-score-scale-factor'
     This variable allows the user to magnify the effect of GroupLens
     scores.  The scale factor is applied after the offset.  The
     default is 1.



File: gnus,  Node: Advanced Scoring,  Next: Score Decays,  Prev: GroupLens,  Up: Scoring

7.16 Advanced Scoring
=====================

Scoring on Subjects and From headers is nice enough, but what if you're
really interested in what a person has to say only when she's talking
about a particular subject?  Or what if you really don't want to read
what person A has to say when she's following up to person B, but want
to read what she says when she's following up to person C?

   By using advanced scoring rules you may create arbitrarily complex
scoring patterns.

* Menu:

* Advanced Scoring Syntax::     A definition.
* Advanced Scoring Examples::   What they look like.
* Advanced Scoring Tips::       Getting the most out of it.


File: gnus,  Node: Advanced Scoring Syntax,  Next: Advanced Scoring Examples,  Up: Advanced Scoring

7.16.1 Advanced Scoring Syntax
------------------------------

Ordinary scoring rules have a string as the first element in the rule.
Advanced scoring rules have a list as the first element.  The second
element is the score to be applied if the first element evaluated to a
non-`nil' value.

   These lists may consist of three logical operators, one redirection
operator, and various match operators.

   Logical operators:

`&'
`and'
     This logical operator will evaluate each of its arguments until it
     finds one that evaluates to `false', and then it'll stop.  If all
     arguments evaluate to `true' values, then this operator will return
     `true'.

`|'
`or'
     This logical operator will evaluate each of its arguments until it
     finds one that evaluates to `true'.  If no arguments are `true',
     then this operator will return `false'.

`!'
`not'
`'
     This logical operator only takes a single argument.  It returns the
     logical negation of the value of its argument.


   There is an "indirection operator" that will make its arguments
apply to the ancestors of the current article being scored.  For
instance, `1-' will make score rules apply to the parent of the current
article.  `2-' will make score rules apply to the grandparent of the
current article.  Alternatively, you can write `^^', where the number
of `^'s (carets) says how far back into the ancestry you want to go.

   Finally, we have the match operators.  These are the ones that do the
real work.  Match operators are header name strings followed by a match
and a match type.  A typical match operator looks like `("from" "Lars
Ingebrigtsen" s)'.  The header names are the same as when using simple
scoring, and the match types are also the same.


File: gnus,  Node: Advanced Scoring Examples,  Next: Advanced Scoring Tips,  Prev: Advanced Scoring Syntax,  Up: Advanced Scoring

7.16.2 Advanced Scoring Examples
--------------------------------

Please note that the following examples are score file rules.  To make
a complete score file from them, surround them with another pair of
parentheses.

   Let's say you want to increase the score of articles written by Lars
when he's talking about Gnus:

     ((&
       ("from" "Lars Ingebrigtsen")
       ("subject" "Gnus"))
      1000)

   Quite simple, huh?

   When he writes long articles, he sometimes has something nice to say:

     ((&
       ("from" "Lars Ingebrigtsen")
       (|
        ("subject" "Gnus")
        ("lines" 100 >)))
      1000)

   However, when he responds to things written by Reig Eigil Logge, you
really don't want to read what he's written:

     ((&
       ("from" "Lars Ingebrigtsen")
       (1- ("from" "Reig Eigir Logge")))
      -100000)

   Everybody that follows up Redmondo when he writes about disappearing
socks should have their scores raised, but only when they talk about
white socks.  However, when Lars talks about socks, it's usually not
very interesting:

     ((&
       (1-
        (&
         ("from" "redmondo@.*no" r)
         ("body" "disappearing.*socks" t)))
       (! ("from" "Lars Ingebrigtsen"))
       ("body" "white.*socks"))
      1000)

   Suppose you're reading a high volume group and you're only interested
in replies. The plan is to score down all articles that don't have
subject that begin with "Re:", "Fw:" or "Fwd:" and then score up all
parents of articles that have subjects that begin with reply marks.

     ((! ("subject" "re:\\|fwd?:" r))
       -200)
     ((1- ("subject" "re:\\|fwd?:" r))
       200)

   The possibilities are endless.


File: gnus,  Node: Advanced Scoring Tips,  Prev: Advanced Scoring Examples,  Up: Advanced Scoring

7.16.3 Advanced Scoring Tips
----------------------------

The `&' and `|' logical operators do short-circuit logic.  That is,
they stop processing their arguments when it's clear what the result of
the operation will be.  For instance, if one of the arguments of an `&'
evaluates to `false', there's no point in evaluating the rest of the
arguments.  This means that you should put slow matches (`body',
`header') last and quick matches (`from', `subject') first.

   The indirection arguments (`1-' and so on) will make their arguments
work on previous generations of the thread.  If you say something like:

     ...
     (1-
      (1-
       ("from" "lars")))
     ...

   Then that means "score on the from header of the grandparent of the
current article".  An indirection is quite fast, but it's better to say:

     (1-
      (&
       ("from" "Lars")
       ("subject" "Gnus")))

   than it is to say:

     (&
      (1- ("from" "Lars"))
      (1- ("subject" "Gnus")))


File: gnus,  Node: Score Decays,  Prev: Advanced Scoring,  Up: Scoring

7.17 Score Decays
=================

You may find that your scores have a tendency to grow without bounds,
especially if you're using adaptive scoring.  If scores get too big,
they lose all meaning--they simply max out and it's difficult to use
them in any sensible way.

   Gnus provides a mechanism for decaying scores to help with this
problem.  When score files are loaded and `gnus-decay-scores' is
non-`nil', Gnus will run the score files through the decaying mechanism
thereby lowering the scores of all non-permanent score rules.  The
decay itself if performed by the `gnus-decay-score-function' function,
which is `gnus-decay-score' by default.  Here's the definition of that
function:

     (defun gnus-decay-score (score)
       "Decay SCORE according to `gnus-score-decay-constant'
     and `gnus-score-decay-scale'."
       (let ((n (- score
                   (* (if (< score 0) -1 1)
                      (min (abs score)
                           (max gnus-score-decay-constant
                                (* (abs score)
                                   gnus-score-decay-scale)))))))
         (if (and (featurep 'xemacs)
                  ;; XEmacs' floor can handle only the floating point
                  ;; number below the half of the maximum integer.
                  (> (abs n) (lsh -1 -2)))
             (string-to-number
              (car (split-string (number-to-string n) "\\.")))
           (floor n))))

   `gnus-score-decay-constant' is 3 by default and
`gnus-score-decay-scale' is 0.05.  This should cause the following:

  1. Scores between -3 and 3 will be set to 0 when this function is
     called.

  2. Scores with magnitudes between 3 and 60 will be shrunk by 3.

  3. Scores with magnitudes greater than 60 will be shrunk by 5% of the
     score.

   If you don't like this decay function, write your own.  It is called
with the score to be decayed as its only parameter, and it should return
the new score, which should be an integer.

   Gnus will try to decay scores once a day.  If you haven't run Gnus
for four days, Gnus will decay the scores four times, for instance.


File: gnus,  Node: Various,  Next: The End,  Prev: Scoring,  Up: Top

8 Various
*********

* Menu:

* Process/Prefix::              A convention used by many treatment commands.
* Interactive::                 Making Gnus ask you many questions.
* Symbolic Prefixes::           How to supply some Gnus functions with options.
* Formatting Variables::        You can specify what buffers should look like.
* Window Layout::               Configuring the Gnus buffer windows.
* Faces and Fonts::             How to change how faces look.
* Compilation::                 How to speed Gnus up.
* Mode Lines::                  Displaying information in the mode lines.
* Highlighting and Menus::      Making buffers look all nice and cozy.
* Buttons::                     Get tendinitis in ten easy steps!
* Daemons::                     Gnus can do things behind your back.
* NoCeM::                       How to avoid spam and other fatty foods.
* Undo::                        Some actions can be undone.
* Predicate Specifiers::        Specifying predicates.
* Moderation::                  What to do if you're a moderator.
* Fetching a Group::            Starting Gnus just to read a group.
* Image Enhancements::          Modern versions of Emacs/XEmacs can display images.
* Fuzzy Matching::              What's the big fuzz?
* Thwarting Email Spam::        A how-to on avoiding unsolicited commercial email.
* Other modes::                 Interaction with other modes.
* Various Various::             Things that are really various.


File: gnus,  Node: Process/Prefix,  Next: Interactive,  Up: Various

8.1 Process/Prefix
==================

Many functions, among them functions for moving, decoding and saving
articles, use what is known as the "Process/Prefix convention".

   This is a method for figuring out what articles the user wants the
command to be performed on.

   It goes like this:

   If the numeric prefix is N, perform the operation on the next N
articles, starting with the current one.  If the numeric prefix is
negative, perform the operation on the previous N articles, starting
with the current one.

   If `transient-mark-mode' in non-`nil' and the region is active, all
articles in the region will be worked upon.

   If there is no numeric prefix, but some articles are marked with the
process mark, perform the operation on the articles marked with the
process mark.

   If there is neither a numeric prefix nor any articles marked with the
process mark, just perform the operation on the current article.

   Quite simple, really, but it needs to be made clear so that surprises
are avoided.

   Commands that react to the process mark will push the current list of
process marked articles onto a stack and will then clear all process
marked articles.  You can restore the previous configuration with the
`M P y' command (*note Setting Process Marks::).

   One thing that seems to shock & horrify lots of people is that, for
instance, `3 d' does exactly the same as `d' `d' `d'.  Since each `d'
(which marks the current article as read) by default goes to the next
unread article after marking, this means that `3 d' will mark the next
three unread articles as read, no matter what the summary buffer looks
like.  Set `gnus-summary-goto-unread' to `nil' for a more
straightforward action.

   Many commands do not use the process/prefix convention.  All commands
that do explicitly say so in this manual.  To apply the process/prefix
convention to commands that do not use it, you can use the `M-&'
command.  For instance, to mark all the articles in the group as
expirable, you could say `M P b M-& E'.


File: gnus,  Node: Interactive,  Next: Symbolic Prefixes,  Prev: Process/Prefix,  Up: Various

8.2 Interactive
===============

`gnus-novice-user'
     If this variable is non-`nil', you are either a newcomer to the
     World of Usenet, or you are very cautious, which is a nice thing
     to be, really.  You will be given questions of the type "Are you
     sure you want to do this?" before doing anything dangerous.  This
     is `t' by default.

`gnus-expert-user'
     If this variable is non-`nil', you will seldom be asked any
     questions by Gnus.  It will simply assume you know what you're
     doing, no matter how strange.

`gnus-interactive-catchup'
     Require confirmation before catching up a group if non-`nil'.  It
     is `t' by default.

`gnus-interactive-exit'
     Require confirmation before exiting Gnus.  This variable is `t' by
     default.


File: gnus,  Node: Symbolic Prefixes,  Next: Formatting Variables,  Prev: Interactive,  Up: Various

8.3 Symbolic Prefixes
=====================

Quite a lot of Emacs commands react to the (numeric) prefix.  For
instance, `C-u 4 C-f' moves point four characters forward, and `C-u 9 0
0 I s s p' adds a permanent `Subject' substring score rule of 900 to
the current article.

   This is all nice and well, but what if you want to give a command
some additional information?  Well, what most commands do is interpret
the "raw" prefix in some special way.  `C-u 0 C-x C-s' means that one
doesn't want a backup file to be created when saving the current buffer,
for instance.  But what if you want to save without making a backup
file, and you want Emacs to flash lights and play a nice tune at the
same time?  You can't, and you're probably perfectly happy that way.

   I'm not, so I've added a second prefix--the "symbolic prefix".  The
prefix key is `M-i' (`gnus-symbolic-argument'), and the next character
typed in is the value.  You can stack as many `M-i' prefixes as you
want.  `M-i a C-M-u' means "feed the `C-M-u' command the symbolic
prefix `a'".  `M-i a M-i b C-M-u' means "feed the `C-M-u' command the
symbolic prefixes `a' and `b'".  You get the drift.

   Typing in symbolic prefixes to commands that don't accept them
doesn't hurt, but it doesn't do any good either.  Currently not many
Gnus functions make use of the symbolic prefix.

   If you're interested in how Gnus implements this, *note Extended
Interactive::.


File: gnus,  Node: Formatting Variables,  Next: Window Layout,  Prev: Symbolic Prefixes,  Up: Various

8.4 Formatting Variables
========================

Throughout this manual you've probably noticed lots of variables called
things like `gnus-group-line-format' and
`gnus-summary-mode-line-format'.  These control how Gnus is to output
lines in the various buffers.  There's quite a lot of them.
Fortunately, they all use the same syntax, so there's not that much to
be annoyed by.

   Here's an example format spec (from the group buffer): `%M%S%5y:
%(%g%)\n'.  We see that it is indeed extremely ugly, and that there are
lots of percentages everywhere.

* Menu:

* Formatting Basics::           A formatting variable is basically a format string.
* Mode Line Formatting::        Some rules about mode line formatting variables.
* Advanced Formatting::         Modifying output in various ways.
* User-Defined Specs::          Having Gnus call your own functions.
* Formatting Fonts::            Making the formatting look colorful and nice.
* Positioning Point::           Moving point to a position after an operation.
* Tabulation::                  Tabulating your output.
* Wide Characters::             Dealing with wide characters.

   Currently Gnus uses the following formatting variables:
`gnus-group-line-format', `gnus-summary-line-format',
`gnus-server-line-format', `gnus-topic-line-format',
`gnus-group-mode-line-format', `gnus-summary-mode-line-format',
`gnus-article-mode-line-format', `gnus-server-mode-line-format', and
`gnus-summary-pick-line-format'.

   All these format variables can also be arbitrary elisp forms.  In
that case, they will be `eval'ed to insert the required lines.

   Gnus includes a command to help you while creating your own format
specs.  `M-x gnus-update-format' will `eval' the current form, update
the spec in question and pop you to a buffer where you can examine the
resulting Lisp code to be run to generate the line.


File: gnus,  Node: Formatting Basics,  Next: Mode Line Formatting,  Up: Formatting Variables

8.4.1 Formatting Basics
-----------------------

Each `%' element will be replaced by some string or other when the
buffer in question is generated.  `%5y' means "insert the `y' spec, and
pad with spaces to get a 5-character field".

   As with normal C and Emacs Lisp formatting strings, the numerical
modifier between the `%' and the formatting type character will "pad"
the output so that it is always at least that long.  `%5y' will make
the field always (at least) five characters wide by padding with spaces
to the left.  If you say `%-5y', it will pad to the right instead.

   You may also wish to limit the length of the field to protect against
particularly wide values.  For that you can say `%4,6y', which means
that the field will never be more than 6 characters wide and never less
than 4 characters wide.

   Also Gnus supports some extended format specifications, such as
`%&user-date;'.


File: gnus,  Node: Mode Line Formatting,  Next: Advanced Formatting,  Prev: Formatting Basics,  Up: Formatting Variables

8.4.2 Mode Line Formatting
--------------------------

Mode line formatting variables (e.g., `gnus-summary-mode-line-format')
follow the same rules as other, buffer line oriented formatting
variables (*note Formatting Basics::) with the following two
differences:

  1. There must be no newline (`\n') at the end.

  2. The special `%%b' spec can be used to display the buffer name.
     Well, it's no spec at all, really--`%%' is just a way to quote `%'
     to allow it to pass through the formatting machinery unmangled, so
     that Emacs receives `%b', which is something the Emacs mode line
     display interprets to mean "show the buffer name".  For a full
     list of mode line specs Emacs understands, see the documentation
     of the `mode-line-format' variable.



File: gnus,  Node: Advanced Formatting,  Next: User-Defined Specs,  Prev: Mode Line Formatting,  Up: Formatting Variables

8.4.3 Advanced Formatting
-------------------------

It is frequently useful to post-process the fields in some way.
Padding, limiting, cutting off parts and suppressing certain values can
be achieved by using "tilde modifiers".  A typical tilde spec might
look like `%~(cut 3)~(ignore "0")y'.

   These are the valid modifiers:

`pad'
`pad-left'
     Pad the field to the left with spaces until it reaches the required
     length.

`pad-right'
     Pad the field to the right with spaces until it reaches the
     required length.

`max'
`max-left'
     Cut off characters from the left until it reaches the specified
     length.

`max-right'
     Cut off characters from the right until it reaches the specified
     length.

`cut'
`cut-left'
     Cut off the specified number of characters from the left.

`cut-right'
     Cut off the specified number of characters from the right.

`ignore'
     Return an empty string if the field is equal to the specified
     value.

`form'
     Use the specified form as the field value when the `@' spec is
     used.

     Here's an example:

          "~(form (current-time-string))@"


   Let's take an example.  The `%o' spec in the summary mode lines will
return a date in compact ISO8601 format--`19960809T230410'.  This is
quite a mouthful, so we want to shave off the century number and the
time, leaving us with a six-character date.  That would be `%~(cut-left
2)~(max-right 6)~(pad 6)o'.  (Cutting is done before maxing, and we
need the padding to ensure that the date is never less than 6
characters to make it look nice in columns.)

   Ignoring is done first; then cutting; then maxing; and then as the
very last operation, padding.

   If you use lots of these advanced thingies, you'll find that Gnus
gets quite slow.  This can be helped enormously by running `M-x
gnus-compile' when you are satisfied with the look of your lines.
*Note Compilation::.


File: gnus,  Node: User-Defined Specs,  Next: Formatting Fonts,  Prev: Advanced Formatting,  Up: Formatting Variables

8.4.4 User-Defined Specs
------------------------

All the specs allow for inserting user defined specifiers--`u'.  The
next character in the format string should be a letter.  Gnus will call
the function `gnus-user-format-function-'`X', where `X' is the letter
following `%u'.  The function will be passed a single parameter--what
the parameter means depends on what buffer it's being called from.  The
function should return a string, which will be inserted into the buffer
just like information from any other specifier.  This function may also
be called with dummy values, so it should protect against that.

   Also Gnus supports extended user-defined specs, such as `%u&foo;'.
Gnus will call the function `gnus-user-format-function-'`foo'.

   You can also use tilde modifiers (*note Advanced Formatting:: to
achieve much the same without defining new functions.  Here's an
example: `%~(form (count-lines (point-min) (point)))@'.  The form given
here will be evaluated to yield the current line number, and then
inserted.


File: gnus,  Node: Formatting Fonts,  Next: Positioning Point,  Prev: User-Defined Specs,  Up: Formatting Variables

8.4.5 Formatting Fonts
----------------------

There are specs for highlighting, and these are shared by all the format
variables.  Text inside the `%(' and `%)' specifiers will get the
special `mouse-face' property set, which means that it will be
highlighted (with `gnus-mouse-face') when you put the mouse pointer
over it.

   Text inside the `%{' and `%}' specifiers will have their normal
faces set using `gnus-face-0', which is `bold' by default.  If you say
`%1{', you'll get `gnus-face-1' instead, and so on.  Create as many
faces as you wish.  The same goes for the `mouse-face' specs--you can
say `%3(hello%)' to have `hello' mouse-highlighted with
`gnus-mouse-face-3'.

   Text inside the `%<<' and `%>>' specifiers will get the special
`balloon-help' property set to `gnus-balloon-face-0'.  If you say
`%1<<', you'll get `gnus-balloon-face-1' and so on.  The
`gnus-balloon-face-*' variables should be either strings or symbols
naming functions that return a string.  When the mouse passes over text
with this property set, a balloon window will appear and display the
string.  Please refer to *Note Tooltips: (emacs)Tooltips, (in GNU
Emacs) or the doc string of `balloon-help-mode' (in XEmacs) for more
information on this.  (For technical reasons, the guillemets have been
approximated as `<<' and `>>' in this paragraph.)

   Here's an alternative recipe for the group buffer:

     ;; Create three face types.
     (setq gnus-face-1 'bold)
     (setq gnus-face-3 'italic)

     ;; We want the article count to be in
     ;; a bold and green face.  So we create
     ;; a new face called `my-green-bold'.
     (copy-face 'bold 'my-green-bold)
     ;; Set the color.
     (set-face-foreground 'my-green-bold "ForestGreen")
     (setq gnus-face-2 'my-green-bold)

     ;; Set the new & fancy format.
     (setq gnus-group-line-format
           "%M%S%3{%5y%}%2[:%] %(%1{%g%}%)\n")

   I'm sure you'll be able to use this scheme to create totally
unreadable and extremely vulgar displays.  Have fun!

   Note that the `%(' specs (and friends) do not make any sense on the
mode-line variables.


File: gnus,  Node: Positioning Point,  Next: Tabulation,  Prev: Formatting Fonts,  Up: Formatting Variables

8.4.6 Positioning Point
-----------------------

Gnus usually moves point to a pre-defined place on each line in most
buffers.  By default, point move to the first colon character on the
line.  You can customize this behavior in three different ways.

   You can move the colon character to somewhere else on the line.

   You can redefine the function that moves the point to the colon.  The
function is called `gnus-goto-colon'.

   But perhaps the most convenient way to deal with this, if you don't
want to have a colon in your line, is to use the `%*' specifier.  If you
put a `%*' somewhere in your format line definition, Gnus will place
point there.


File: gnus,  Node: Tabulation,  Next: Wide Characters,  Prev: Positioning Point,  Up: Formatting Variables

8.4.7 Tabulation
----------------

You can usually line up your displays by padding and cutting your
strings.  However, when combining various strings of different size, it
can often be more convenient to just output the strings, and then worry
about lining up the following text afterwards.

   To do that, Gnus supplies tabulator specs--`%='.  There are two
different types--"hard tabulators" and "soft tabulators".

   `%50=' will insert space characters to pad the line up to column 50.
If the text is already past column 50, nothing will be inserted.  This
is the soft tabulator.

   `%-50=' will insert space characters to pad the line up to column
50.  If the text is already past column 50, the excess text past column
50 will be removed.  This is the hard tabulator.


File: gnus,  Node: Wide Characters,  Prev: Tabulation,  Up: Formatting Variables

8.4.8 Wide Characters
---------------------

Fixed width fonts in most countries have characters of the same width.
Some countries, however, use Latin characters mixed with wider
characters--most notable East Asian countries.

   The problem is that when formatting, Gnus assumes that if a string
is 10 characters wide, it'll be 10 Latin characters wide on the screen.
In these countries, that's not true.

   To help fix this, you can set `gnus-use-correct-string-widths' to
`t'.  This makes buffer generation slower, but the results will be
prettier.  The default value under XEmacs is `t' but `nil' for Emacs.


File: gnus,  Node: Window Layout,  Next: Faces and Fonts,  Prev: Formatting Variables,  Up: Various

8.5 Window Layout
=================

No, there's nothing here about X, so be quiet.

   If `gnus-use-full-window' non-`nil', Gnus will delete all other
windows and occupy the entire Emacs screen by itself.  It is `t' by
default.

   Setting this variable to `nil' kinda works, but there are glitches.
Use at your own peril.

   `gnus-buffer-configuration' describes how much space each Gnus
buffer should be given.  Here's an excerpt of this variable:

     ((group (vertical 1.0 (group 1.0 point)
                           (if gnus-carpal (group-carpal 4))))
      (article (vertical 1.0 (summary 0.25 point)
                             (article 1.0))))

   This is an alist.  The "key" is a symbol that names some action or
other.  For instance, when displaying the group buffer, the window
configuration function will use `group' as the key.  A full list of
possible names is listed below.

   The "value" (i.e., the "split") says how much space each buffer
should occupy.  To take the `article' split as an example -

     (article (vertical 1.0 (summary 0.25 point)
                            (article 1.0)))

   This "split" says that the summary buffer should occupy 25% of upper
half of the screen, and that it is placed over the article buffer.  As
you may have noticed, 100% + 25% is actually 125% (yup, I saw y'all
reaching for that calculator there).  However, the special number `1.0'
is used to signal that this buffer should soak up all the rest of the
space available after the rest of the buffers have taken whatever they
need.  There should be only one buffer with the `1.0' size spec per
split.

   Point will be put in the buffer that has the optional third element
`point'.  In a `frame' split, the last subsplit having a leaf split
where the tag `frame-focus' is a member (i.e. is the third or fourth
element in the list, depending on whether the `point' tag is present)
gets focus.

   Here's a more complicated example:

     (article (vertical 1.0 (group 4)
                            (summary 0.25 point)
                            (if gnus-carpal (summary-carpal 4))
                            (article 1.0)))

   If the size spec is an integer instead of a floating point number,
then that number will be used to say how many lines a buffer should
occupy, not a percentage.

   If the "split" looks like something that can be `eval'ed (to be
precise--if the `car' of the split is a function or a subr), this split
will be `eval'ed.  If the result is non-`nil', it will be used as a
split.  This means that there will be three buffers if `gnus-carpal' is
`nil', and four buffers if `gnus-carpal' is non-`nil'.

   Not complicated enough for you?  Well, try this on for size:

     (article (horizontal 1.0
                  (vertical 0.5
                      (group 1.0)
                      (gnus-carpal 4))
                  (vertical 1.0
                      (summary 0.25 point)
                      (summary-carpal 4)
                      (article 1.0))))

   Whoops.  Two buffers with the mystery 100% tag.  And what's that
`horizontal' thingie?

   If the first element in one of the split is `horizontal', Gnus will
split the window horizontally, giving you two windows side-by-side.
Inside each of these strips you may carry on all you like in the normal
fashion.  The number following `horizontal' says what percentage of the
screen is to be given to this strip.

   For each split, there _must_ be one element that has the 100% tag.
The splitting is never accurate, and this buffer will eat any leftover
lines from the splits.

   To be slightly more formal, here's a definition of what a valid split
may look like:

     split      = frame | horizontal | vertical | buffer | form
     frame      = "(frame " size *split ")"
     horizontal = "(horizontal " size *split ")"
     vertical   = "(vertical " size *split ")"
     buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
     size       = number | frame-params
     buf-name   = group | article | summary ...

   The limitations are that the `frame' split can only appear as the
top-level split.  FORM should be an Emacs Lisp form that should return
a valid split.  We see that each split is fully recursive, and may
contain any number of `vertical' and `horizontal' splits.

   Finding the right sizes can be a bit complicated.  No window may be
less than `gnus-window-min-height' (default 1) characters high, and all
windows must be at least `gnus-window-min-width' (default 1) characters
wide.  Gnus will try to enforce this before applying the splits.  If
you want to use the normal Emacs window width/height limit, you can
just set these two variables to `nil'.

   If you're not familiar with Emacs terminology, `horizontal' and
`vertical' splits may work the opposite way of what you'd expect.
Windows inside a `horizontal' split are shown side-by-side, and windows
within a `vertical' split are shown above each other.

   If you want to experiment with window placement, a good tip is to
call `gnus-configure-frame' directly with a split.  This is the function
that does all the real work when splitting buffers.  Below is a pretty
nonsensical configuration with 5 windows; two for the group buffer and
three for the article buffer.  (I said it was nonsensical.)  If you
`eval' the statement below, you can get an idea of how that would look
straight away, without going through the normal Gnus channels.  Play
with it until you're satisfied, and then use `gnus-add-configuration'
to add your new creation to the buffer configuration list.

     (gnus-configure-frame
      '(horizontal 1.0
         (vertical 10
           (group 1.0)
           (article 0.3 point))
         (vertical 1.0
           (article 1.0)
           (horizontal 4
             (group 1.0)
             (article 10)))))

   You might want to have several frames as well.  No prob--just use the
`frame' split:

     (gnus-configure-frame
      '(frame 1.0
              (vertical 1.0
                        (summary 0.25 point frame-focus)
                        (article 1.0))
              (vertical ((height . 5) (width . 15)
                         (user-position . t)
                         (left . -1) (top . 1))
                        (picon 1.0))))

   This split will result in the familiar summary/article window
configuration in the first (or "main") frame, while a small additional
frame will be created where picons will be shown.  As you can see,
instead of the normal `1.0' top-level spec, each additional split
should have a frame parameter alist as the size spec.  *Note Frame
Parameters: (elisp)Frame Parameters.  Under XEmacs, a frame property
list will be accepted, too--for instance, `(height 5 width 15 left -1
top 1)' is such a plist.  The list of all possible keys for
`gnus-buffer-configuration' can be found in its default value.

   Note that the `message' key is used for both `gnus-group-mail' and
`gnus-summary-mail-other-window'.  If it is desirable to distinguish
between the two, something like this might be used:

     (message (horizontal 1.0
                          (vertical 1.0 (message 1.0 point))
                          (vertical 0.24
                                    (if (buffer-live-p gnus-summary-buffer)
                                        '(summary 0.5))
                                    (group 1.0))))

   One common desire for a multiple frame split is to have a separate
frame for composing mail and news while leaving the original frame
intact.  To accomplish that, something like the following can be done:

     (message
       (frame 1.0
              (if (not (buffer-live-p gnus-summary-buffer))
                  (car (cdr (assoc 'group gnus-buffer-configuration)))
                (car (cdr (assoc 'summary gnus-buffer-configuration))))
              (vertical ((user-position . t) (top . 1) (left . 1)
                         (name . "Message"))
                        (message 1.0 point))))

   Since the `gnus-buffer-configuration' variable is so long and
complicated, there's a function you can use to ease changing the config
of a single setting: `gnus-add-configuration'.  If, for instance, you
want to change the `article' setting, you could say:

     (gnus-add-configuration
      '(article (vertical 1.0
                    (group 4)
                    (summary .25 point)
                    (article 1.0))))

   You'd typically stick these `gnus-add-configuration' calls in your
`~/.gnus.el' file or in some startup hook--they should be run after
Gnus has been loaded.

   If all windows mentioned in the configuration are already visible,
Gnus won't change the window configuration.  If you always want to
force the "right" window configuration, you can set
`gnus-always-force-window-configuration' to non-`nil'.

   If you're using tree displays (*note Tree Display::), and the tree
window is displayed vertically next to another window, you may also want
to fiddle with `gnus-tree-minimize-window' to avoid having the windows
resized.

8.5.1 Example Window Configurations
-----------------------------------

   * Narrow left hand side occupied by group buffer.  Right hand side
     split between summary buffer (top one-sixth) and article buffer
     (bottom).

          +---+---------+
          | G | Summary |
          | r +---------+
          | o |         |
          | u | Article |
          | p |         |
          +---+---------+

          (gnus-add-configuration
           '(article
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0
                                   (summary 0.16 point)
                                   (article 1.0)))))

          (gnus-add-configuration
           '(summary
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0 (summary 1.0 point)))))



File: gnus,  Node: Faces and Fonts,  Next: Compilation,  Prev: Window Layout,  Up: Various

8.6 Faces and Fonts
===================

Fiddling with fonts and faces used to be very difficult, but these days
it is very simple.  You simply say `M-x customize-face', pick out the
face you want to alter, and alter it via the standard Customize
interface.


File: gnus,  Node: Compilation,  Next: Mode Lines,  Prev: Faces and Fonts,  Up: Various

8.7 Compilation
===============

Remember all those line format specification variables?
`gnus-summary-line-format', `gnus-group-line-format', and so on.  Now,
Gnus will of course heed whatever these variables are, but,
unfortunately, changing them will mean a quite significant slow-down.
(The default values of these variables have byte-compiled functions
associated with them, while the user-generated versions do not, of
course.)

   To help with this, you can run `M-x gnus-compile' after you've
fiddled around with the variables and feel that you're (kind of)
satisfied.  This will result in the new specs being byte-compiled, and
you'll get top speed again.  Gnus will save these compiled specs in the
`.newsrc.eld' file.  (User-defined functions aren't compiled by this
function, though--you should compile them yourself by sticking them
into the `~/.gnus.el' file and byte-compiling that file.)


File: gnus,  Node: Mode Lines,  Next: Highlighting and Menus,  Prev: Compilation,  Up: Various

8.8 Mode Lines
==============

`gnus-updated-mode-lines' says what buffers should keep their mode
lines updated.  It is a list of symbols.  Supported symbols include
`group', `article', `summary', `server', `browse', and `tree'.  If the
corresponding symbol is present, Gnus will keep that mode line updated
with information that may be pertinent.  If this variable is `nil',
screen refresh may be quicker.

   By default, Gnus displays information on the current article in the
mode lines of the summary and article buffers.  The information Gnus
wishes to display (e.g. the subject of the article) is often longer
than the mode lines, and therefore have to be cut off at some point.
The `gnus-mode-non-string-length' variable says how long the other
elements on the line is (i.e., the non-info part).  If you put
additional elements on the mode line (e.g. a clock), you should modify
this variable:

     (add-hook 'display-time-hook
               (lambda () (setq gnus-mode-non-string-length
                                (+ 21
                                   (if line-number-mode 5 0)
                                   (if column-number-mode 4 0)
                                   (length display-time-string)))))

   If this variable is `nil' (which is the default), the mode line
strings won't be chopped off, and they won't be padded either.  Note
that the default is unlikely to be desirable, as even the percentage
complete in the buffer may be crowded off the mode line; the user should
configure this variable appropriately for her configuration.


File: gnus,  Node: Highlighting and Menus,  Next: Buttons,  Prev: Mode Lines,  Up: Various

8.9 Highlighting and Menus
==========================

The `gnus-visual' variable controls most of the Gnus-prettifying
aspects.  If `nil', Gnus won't attempt to create menus or use fancy
colors or fonts.  This will also inhibit loading the `gnus-vis.el' file.

   This variable can be a list of visual properties that are enabled.
The following elements are valid, and are all included by default:

`group-highlight'
     Do highlights in the group buffer.

`summary-highlight'
     Do highlights in the summary buffer.

`article-highlight'
     Do highlights in the article buffer.

`highlight'
     Turn on highlighting in all buffers.

`group-menu'
     Create menus in the group buffer.

`summary-menu'
     Create menus in the summary buffers.

`article-menu'
     Create menus in the article buffer.

`browse-menu'
     Create menus in the browse buffer.

`server-menu'
     Create menus in the server buffer.

`score-menu'
     Create menus in the score buffers.

`menu'
     Create menus in all buffers.

   So if you only want highlighting in the article buffer and menus in
all buffers, you could say something like:

     (setq gnus-visual '(article-highlight menu))

   If you want highlighting only and no menus whatsoever, you'd say:

     (setq gnus-visual '(highlight))

   If `gnus-visual' is `t', highlighting and menus will be used in all
Gnus buffers.

   Other general variables that influence the look of all buffers
include:

`gnus-mouse-face'
     This is the face (i.e., font) used for mouse highlighting in Gnus.
     No mouse highlights will be done if `gnus-visual' is `nil'.


   There are hooks associated with the creation of all the different
menus:

`gnus-article-menu-hook'
     Hook called after creating the article mode menu.

`gnus-group-menu-hook'
     Hook called after creating the group mode menu.

`gnus-summary-menu-hook'
     Hook called after creating the summary mode menu.

`gnus-server-menu-hook'
     Hook called after creating the server mode menu.

`gnus-browse-menu-hook'
     Hook called after creating the browse mode menu.

`gnus-score-menu-hook'
     Hook called after creating the score mode menu.



File: gnus,  Node: Buttons,  Next: Daemons,  Prev: Highlighting and Menus,  Up: Various

8.10 Buttons
============

Those new-fangled "mouse" contraptions is very popular with the young,
hep kids who don't want to learn the proper way to do things these
days.  Why, I remember way back in the summer of '89, when I was using
Emacs on a Tops 20 system.  Three hundred users on one single machine,
and every user was running Simula compilers.  Bah!

   Right.

   Well, you can make Gnus display bufferfuls of buttons you can click
to do anything by setting `gnus-carpal' to `t'.  Pretty simple, really.
Tell the chiropractor I sent you.

`gnus-carpal-mode-hook'
     Hook run in all carpal mode buffers.

`gnus-carpal-button-face'
     Face used on buttons.

`gnus-carpal-header-face'
     Face used on carpal buffer headers.

`gnus-carpal-group-buffer-buttons'
     Buttons in the group buffer.

`gnus-carpal-summary-buffer-buttons'
     Buttons in the summary buffer.

`gnus-carpal-server-buffer-buttons'
     Buttons in the server buffer.

`gnus-carpal-browse-buffer-buttons'
     Buttons in the browse buffer.

   All the `buttons' variables are lists.  The elements in these list
are either cons cells where the `car' contains a text to be displayed
and the `cdr' contains a function symbol, or a simple string.


File: gnus,  Node: Daemons,  Next: NoCeM,  Prev: Buttons,  Up: Various

8.11 Daemons
============

Gnus, being larger than any program ever written (allegedly), does lots
of strange stuff that you may wish to have done while you're not
present.  For instance, you may want it to check for new mail once in a
while.  Or you may want it to close down all connections to all servers
when you leave Emacs idle.  And stuff like that.

   Gnus will let you do stuff like that by defining various "handlers".
Each handler consists of three elements:  A FUNCTION, a TIME, and an
IDLE parameter.

   Here's an example of a handler that closes connections when Emacs has
been idle for thirty minutes:

     (gnus-demon-close-connections nil 30)

   Here's a handler that scans for PGP headers every hour when Emacs is
idle:

     (gnus-demon-scan-pgp 60 t)

   This TIME parameter and that IDLE parameter work together in a
strange, but wonderful fashion.  Basically, if IDLE is `nil', then the
function will be called every TIME minutes.

   If IDLE is `t', then the function will be called after TIME minutes
only if Emacs is idle.  So if Emacs is never idle, the function will
never be called.  But once Emacs goes idle, the function will be called
every TIME minutes.

   If IDLE is a number and TIME is a number, the function will be
called every TIME minutes only when Emacs has been idle for IDLE
minutes.

   If IDLE is a number and TIME is `nil', the function will be called
once every time Emacs has been idle for IDLE minutes.

   And if TIME is a string, it should look like `07:31', and the
function will then be called once every day somewhere near that time.
Modified by the IDLE parameter, of course.

   (When I say "minute" here, I really mean `gnus-demon-timestep'
seconds.  This is 60 by default.  If you change that variable, all the
timings in the handlers will be affected.)

   So, if you want to add a handler, you could put something like this
in your `~/.gnus.el' file:

     (gnus-demon-add-handler 'gnus-demon-close-connections 30 t)

   Some ready-made functions to do this have been created:
`gnus-demon-add-nocem', `gnus-demon-add-disconnection',
`gnus-demon-add-nntp-close-connection',
`gnus-demon-add-scan-timestamps', `gnus-demon-add-rescan', and
`gnus-demon-add-scanmail'.  Just put those functions in your
`~/.gnus.el' if you want those abilities.

   If you add handlers to `gnus-demon-handlers' directly, you should
run `gnus-demon-init' to make the changes take hold.  To cancel all
daemons, you can use the `gnus-demon-cancel' function.

   Note that adding daemons can be pretty naughty if you over do it.
Adding functions that scan all news and mail from all servers every two
seconds is a sure-fire way of getting booted off any respectable
system.  So behave.


File: gnus,  Node: NoCeM,  Next: Undo,  Prev: Daemons,  Up: Various

8.12 NoCeM
==========

"Spamming" is posting the same article lots and lots of times.
Spamming is bad.  Spamming is evil.

   Spamming is usually canceled within a day or so by various
anti-spamming agencies.  These agencies usually also send out "NoCeM"
messages.  NoCeM is pronounced "no see-'em", and means what the name
implies--these are messages that make the offending articles, like, go
away.

   What use are these NoCeM messages if the articles are canceled
anyway?  Some sites do not honor cancel messages and some sites just
honor cancels from a select few people.  Then you may wish to make use
of the NoCeM messages, which are distributed in the `alt.nocem.misc'
newsgroup.

   Gnus can read and parse the messages in this group automatically, and
this will make spam disappear.

   There are some variables to customize, of course:

`gnus-use-nocem'
     Set this variable to `t' to set the ball rolling.  It is `nil' by
     default.

     You can also set this variable to a positive number as a group
     level.  In that case, Gnus scans NoCeM messages when checking new
     news if this value is not exceeding a group level that you specify
     as the prefix argument to some commands, e.g. `gnus',
     `gnus-group-get-new-news', etc.  Otherwise, Gnus does not scan
     NoCeM messages if you specify a group level to those commands.  For
     example, if you use 1 or 2 on the mail groups and the levels on
     the news groups remain the default, 3 is the best choice.

`gnus-nocem-groups'
     Gnus will look for NoCeM messages in the groups in this list.  The
     default is
          ("news.lists.filters" "news.admin.net-abuse.bulletins"
           "alt.nocem.misc" "news.admin.net-abuse.announce")

`gnus-nocem-issuers'
     There are many people issuing NoCeM messages.  This list says what
     people you want to listen to.  The default is
          ("Automoose-1" "clewis@ferret.ocunix.on.ca"
           "cosmo.roadkill" "SpamHippo" "hweede@snafu.de")
     fine, upstanding citizens all of them.

     Known despammers that you can put in this list are listed at
     `http://www.xs4all.nl/~rosalind/nocemreg/nocemreg.html'.

     You do not have to heed NoCeM messages from all these people--just
     the ones you want to listen to.  You also don't have to accept all
     NoCeM messages from the people you like.  Each NoCeM message has a
     "type" header that gives the message a (more or less, usually
     less) rigorous definition.  Common types are `spam', `spew', `mmf',
     `binary', and `troll'.  To specify this, you have to use `(ISSUER
     CONDITIONS ...)' elements in the list.  Each condition is either a
     string (which is a regexp that matches types you want to use) or a
     list on the form `(not STRING)', where STRING is a regexp that
     matches types you don't want to use.

     For instance, if you want all NoCeM messages from Chris Lewis
     except his `troll' messages, you'd say:

          ("clewis@ferret.ocunix.on.ca" ".*" (not "troll"))

     On the other hand, if you just want nothing but his `spam' and
     `spew' messages, you'd say:

          ("clewis@ferret.ocunix.on.ca" (not ".*") "spew" "spam")

     The specs are applied left-to-right.

`gnus-nocem-verifyer'
     This should be a function for verifying that the NoCeM issuer is
     who she says she is.  The default is `pgg-verify', which returns
     non-`nil' if the verification is successful, otherwise (including
     the case the NoCeM message was not signed) returns `nil'.  If this
     is too slow and you don't care for verification (which may be
     dangerous), you can set this variable to `nil'.

     Formerly the default was `mc-verify', which is a Mailcrypt
     function.  While you can still use it, you can change it into
     `pgg-verify' running with GnuPG if you are willing to add the PGP
     public keys to GnuPG's keyring.

`gnus-nocem-directory'
     This is where Gnus will store its NoCeM cache files.  The default
     is
     `~/News/NoCeM/'.

`gnus-nocem-expiry-wait'
     The number of days before removing old NoCeM entries from the
     cache.  The default is 15.  If you make it shorter Gnus will be
     faster, but you might then see old spam.

`gnus-nocem-check-from'
     Non-`nil' means check for valid issuers in message bodies.
     Otherwise don't bother fetching articles unless their author
     matches a valid issuer; that is much faster if you are selective
     about the issuers.

`gnus-nocem-check-article-limit'
     If non-`nil', the maximum number of articles to check in any NoCeM
     group.  NoCeM groups can be huge and very slow to process.


   Using NoCeM could potentially be a memory hog.  If you have many
living (i. e., subscribed or unsubscribed groups), your Emacs process
will grow big.  If this is a problem, you should kill off all (or most)
of your unsubscribed groups (*note Subscription Commands::).


File: gnus,  Node: Undo,  Next: Predicate Specifiers,  Prev: NoCeM,  Up: Various

8.13 Undo
=========

It is very useful to be able to undo actions one has done.  In normal
Emacs buffers, it's easy enough--you just push the `undo' button.  In
Gnus buffers, however, it isn't that simple.

   The things Gnus displays in its buffer is of no value whatsoever to
Gnus--it's all just data designed to look nice to the user.  Killing a
group in the group buffer with `C-k' makes the line disappear, but
that's just a side-effect of the real action--the removal of the group
in question from the internal Gnus structures.  Undoing something like
that can't be done by the normal Emacs `undo' function.

   Gnus tries to remedy this somewhat by keeping track of what the user
does and coming up with actions that would reverse the actions the user
takes.  When the user then presses the `undo' key, Gnus will run the
code to reverse the previous action, or the previous actions.  However,
not all actions are easily reversible, so Gnus currently offers a few
key functions to be undoable.  These include killing groups, yanking
groups, and changing the list of read articles of groups.  That's it,
really.  More functions may be added in the future, but each added
function means an increase in data to be stored, so Gnus will never be
totally undoable.

   The undoability is provided by the `gnus-undo-mode' minor mode.  It
is used if `gnus-use-undo' is non-`nil', which is the default.  The
`C-M-_' key performs the `gnus-undo' command, which should feel kinda
like the normal Emacs `undo' command.


File: gnus,  Node: Predicate Specifiers,  Next: Moderation,  Prev: Undo,  Up: Various

8.14 Predicate Specifiers
=========================

Some Gnus variables are "predicate specifiers".  This is a special form
that allows flexible specification of predicates without having to type
all that much.

   These specifiers are lists consisting of functions, symbols and
lists.

   Here's an example:

     (or gnus-article-unseen-p
         gnus-article-unread-p)

   The available symbols are `or', `and' and `not'.  The functions all
take one parameter.

   Internally, Gnus calls `gnus-make-predicate' on these specifiers to
create a function that can be called.  This input parameter to this
function will be passed along to all the functions in the predicate
specifier.


File: gnus,  Node: Moderation,  Next: Fetching a Group,  Prev: Predicate Specifiers,  Up: Various

8.15 Moderation
===============

If you are a moderator, you can use the `gnus-mdrtn.el' package.  It is
not included in the standard Gnus package.  Write a mail to
`larsi@gnus.org' and state what group you moderate, and you'll get a
copy.

   The moderation package is implemented as a minor mode for summary
buffers.  Put

     (add-hook 'gnus-summary-mode-hook 'gnus-moderate)

   in your `~/.gnus.el' file.

   If you are the moderator of `rec.zoofle', this is how it's supposed
to work:

  1. You split your incoming mail by matching on
     `Newsgroups:.*rec.zoofle', which will put all the to-be-posted
     articles in some mail group--for instance, `nnml:rec.zoofle'.

  2. You enter that group once in a while and post articles using the
     `e' (edit-and-post) or `s' (just send unedited) commands.

  3. If, while reading the `rec.zoofle' newsgroup, you happen upon some
     articles that weren't approved by you, you can cancel them with the
     `c' command.

   To use moderation mode in these two groups, say:

     (setq gnus-moderated-list
           "^nnml:rec.zoofle$\\|^rec.zoofle$")


File: gnus,  Node: Fetching a Group,  Next: Image Enhancements,  Prev: Moderation,  Up: Various

8.16 Fetching a Group
=====================

It is sometimes convenient to be able to just say "I want to read this
group and I don't care whether Gnus has been started or not".  This is
perhaps more useful for people who write code than for users, but the
command `gnus-fetch-group' provides this functionality in any case.  It
takes the group name as a parameter.


File: gnus,  Node: Image Enhancements,  Next: Fuzzy Matching,  Prev: Fetching a Group,  Up: Various

8.17 Image Enhancements
=======================

XEmacs, as well as Emacs 21(1), is able to display pictures and stuff,
so Gnus has taken advantage of that.

* Menu:

* X-Face::                      Display a funky, teensy black-and-white image.
* Face::                        Display a funkier, teensier colored image.
* Smileys::                     Show all those happy faces the way they were meant to be shown.
* Picons::                      How to display pictures of what you're reading.
* XVarious::                    Other XEmacsy Gnusey variables.

   ---------- Footnotes ----------

   (1) Emacs 21 on MS Windows doesn't support images yet.


File: gnus,  Node: X-Face,  Next: Face,  Up: Image Enhancements

8.17.1 X-Face
-------------

`X-Face' headers describe a 48x48 pixel black-and-white (1 bit depth)
image that's supposed to represent the author of the message.  It seems
to be supported by an ever-growing number of mail and news readers.

   Viewing an `X-Face' header either requires an Emacs that has
`compface' support (which most XEmacs versions has), or that you have
suitable conversion or display programs installed.  If your Emacs has
image support the default action is to display the face before the
`From' header.  If there's no native `X-Face' support, Gnus will try to
convert the `X-Face' header using external programs from the `pbmplus'
package and friends.  For XEmacs it's faster if XEmacs has been
compiled with `X-Face' support.  The default action under Emacs without
image support is to fork off the `display' program.

   On a GNU/Linux system, the `display' program is from the ImageMagick
package.  For external conversion programs look for packages with names
like `netpbm', `libgr-progs' and `compface'.

   The variable that controls this is the `gnus-article-x-face-command'
variable.  If this variable is a string, this string will be executed
in a sub-shell.  If it is a function, this function will be called with
the face as the argument.  If the `gnus-article-x-face-too-ugly' (which
is a regexp) matches the `From' header, the face will not be shown.

   (Note: `x-face' is used in the variable/function names, not `xface').

Face and variable:

`gnus-x-face'
     Face to show X-Face.  The colors from this face are used as the
     foreground and background colors of the displayed X-Faces.  The
     default colors are black and white.

   If you use posting styles, you can use an `x-face-file' entry in
`gnus-posting-styles', *Note Posting Styles::.  If you don't, Gnus
provides a few convenience functions and variables to allow easier
insertion of X-Face headers in outgoing messages.  You also need the
above mentioned ImageMagick, netpbm or other image conversion packages
(depending the values of the variables below) for these functions.

   `gnus-random-x-face' goes through all the `pbm' files in
`gnus-x-face-directory' and picks one at random, and then converts it
to the X-Face format by using the `gnus-convert-pbm-to-x-face-command'
shell command.  The `pbm' files should be 48x48 pixels big.  It returns
the X-Face header data as a string.

   `gnus-insert-random-x-face-header' calls `gnus-random-x-face' and
inserts a `X-Face' header with the randomly generated data.

   `gnus-x-face-from-file' takes a GIF file as the parameter, and then
converts the file to X-Face format by using the
`gnus-convert-image-to-x-face-command' shell command.

   Here's how you would typically use the first function.  Put something
like the following in your `~/.gnus.el' file:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(X-Face . gnus-random-x-face))))

   Using the last function would be something like this:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(X-Face . (lambda ()
                                     (gnus-x-face-from-file
                                      "~/My-face.gif"))))))


File: gnus,  Node: Face,  Next: Smileys,  Prev: X-Face,  Up: Image Enhancements

8.17.2 Face
-----------

`Face' headers are essentially a funkier version of `X-Face' ones. They
describe a 48x48 pixel colored image that's supposed to represent the
author of the message.

   The contents of a `Face' header must be a base64 encoded PNG image.
See `http://quimby.gnus.org/circus/face/' for the precise
specifications.

   Viewing an `Face' header requires an Emacs that is able to display
PNG images.

   Gnus provides a few convenience functions and variables to allow
easier insertion of Face headers in outgoing messages.

   `gnus-convert-png-to-face' takes a 48x48 PNG image, no longer than
726 bytes long, and converts it to a face.

   `gnus-face-from-file' takes a JPEG file as the parameter, and then
converts the file to Face format by using the
`gnus-convert-image-to-face-command' shell command.

   Here's how you would typically use this function. Put something like
the following in your `~/.gnus.el' file:

     (setq message-required-news-headers
           (nconc message-required-news-headers
                  (list '(Face . (lambda ()
                                   (gnus-face-from-file "~/face.jpg"))))))


File: gnus,  Node: Smileys,  Next: Picons,  Prev: Face,  Up: Image Enhancements

8.17.3 Smileys
--------------

"Smiley" is a package separate from Gnus, but since Gnus is currently
the only package that uses Smiley, it is documented here.

   In short--to use Smiley in Gnus, put the following in your
`~/.gnus.el' file:

     (setq gnus-treat-display-smileys t)

   Smiley maps text smiley faces--`:-)', `8-)', `:-(' and the like--to
pictures and displays those instead of the text smiley faces.  The
conversion is controlled by a list of regexps that matches text and
maps that to file names.

   The alist used is specified by the `smiley-regexp-alist' variable.
The first item in each element is the regexp to be matched; the second
element is the regexp match group that is to be replaced by the
picture; and the third element is the name of the file to be displayed.

   The following variables customize where Smiley will look for these
files:

`smiley-data-directory'
     Where Smiley will look for smiley faces files.

`gnus-smiley-file-types'
     List of suffixes on smiley file names to try.



File: gnus,  Node: Picons,  Next: XVarious,  Prev: Smileys,  Up: Image Enhancements

8.17.4 Picons
-------------

So...  You want to slow down your news reader even more!  This is a
good way to do so.  It's also a great way to impress people staring
over your shoulder as you read news.

   What are Picons?  To quote directly from the Picons Web site:

     "Picons" is short for "personal icons".  They're small,
     constrained images used to represent users and domains on the net,
     organized into databases so that the appropriate image for a given
     e-mail address can be found.  Besides users and domains, there are
     picon databases for Usenet newsgroups and weather forecasts.  The
     picons are in either monochrome `XBM' format or color `XPM' and
     `GIF' formats.

   For instructions on obtaining and installing the picons databases,
point your Web browser at
`http://www.cs.indiana.edu/picons/ftp/index.html'.

   If you are using Debian GNU/Linux, saying `apt-get install picons.*'
will install the picons where Gnus can find them.

   To enable displaying picons, simply make sure that
`gnus-picon-databases' points to the directory containing the Picons
databases.

   The following variables offer control over where things are located.

`gnus-picon-databases'
     The location of the picons database.  This is a list of directories
     containing the `news', `domains', `users' (and so on)
     subdirectories.  Defaults to `("/usr/lib/picon"
     "/usr/local/faces")'.

`gnus-picon-news-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     newsgroups faces.  `("news")' is the default.

`gnus-picon-user-directories'
     List of subdirectories to search in `gnus-picon-databases' for user
     faces.  `("users" "usenix" "local" "misc")' is the default.

`gnus-picon-domain-directories'
     List of subdirectories to search in `gnus-picon-databases' for
     domain name faces.  Defaults to `("domains")'.  Some people may
     want to add `"unknown"' to this list.

`gnus-picon-file-types'
     Ordered list of suffixes on picon file names to try.  Defaults to
     `("xpm" "gif" "xbm")' minus those not built-in your Emacs.



File: gnus,  Node: XVarious,  Prev: Picons,  Up: Image Enhancements

8.17.5 Various XEmacs Variables
-------------------------------

`gnus-xmas-glyph-directory'
     This is where Gnus will look for pictures.  Gnus will normally
     auto-detect this directory, but you may set it manually if you
     have an unusual directory structure.

`gnus-xmas-modeline-glyph'
     A glyph displayed in all Gnus mode lines.  It is a tiny gnu head by
     default.


8.17.5.1 Toolbar
................

`gnus-use-toolbar'
     This variable specifies the position to display the toolbar.  If
     `nil', don't display toolbars.  If it is non-`nil', it should be
     one of the symbols `default', `top', `bottom', `right', and
     `left'.  `default' means to use the default toolbar, the rest mean
     to display the toolbar on the place which those names show.  The
     default is `default'.

`gnus-toolbar-thickness'
     Cons of the height and the width specifying the thickness of a
     toolbar.  The height is used for the toolbar displayed on the top
     or the bottom, the width is used for the toolbar displayed on the
     right or the left.  The default is that of the default toolbar.

`gnus-group-toolbar'
     The toolbar in the group buffer.

`gnus-summary-toolbar'
     The toolbar in the summary buffer.

`gnus-summary-mail-toolbar'
     The toolbar in the summary buffer of mail groups.



File: gnus,  Node: Fuzzy Matching,  Next: Thwarting Email Spam,  Prev: Image Enhancements,  Up: Various

8.18 Fuzzy Matching
===================

Gnus provides "fuzzy matching" of `Subject' lines when doing things
like scoring, thread gathering and thread comparison.

   As opposed to regular expression matching, fuzzy matching is very
fuzzy.  It's so fuzzy that there's not even a definition of what
"fuzziness" means, and the implementation has changed over time.

   Basically, it tries to remove all noise from lines before comparing.
`Re: ', parenthetical remarks, white space, and so on, are filtered out
of the strings before comparing the results.  This often leads to
adequate results--even when faced with strings generated by text
manglers masquerading as newsreaders.


File: gnus,  Node: Thwarting Email Spam,  Next: Other modes,  Prev: Fuzzy Matching,  Up: Various

8.19 Thwarting Email Spam
=========================

In these last days of the Usenet, commercial vultures are hanging about
and grepping through news like crazy to find email addresses they can
foist off their scams and products to.  As a reaction to this, many
people have started putting nonsense addresses into their `From' lines.
I think this is counterproductive--it makes it difficult for people to
send you legitimate mail in response to things you write, as well as
making it difficult to see who wrote what.  This rewriting may perhaps
be a bigger menace than the unsolicited commercial email itself in the
end.

   The biggest problem I have with email spam is that it comes in under
false pretenses.  I press `g' and Gnus merrily informs me that I have
10 new emails.  I say "Golly gee!  Happy is me!" and select the mail
group, only to find two pyramid schemes, seven advertisements ("New!
Miracle tonic for growing full, lustrous hair on your toes!")  and one
mail asking me to repent and find some god.

   This is annoying.  Here's what you can do about it.

* Menu:

* The problem of spam::         Some background, and some solutions
* Anti-Spam Basics::            Simple steps to reduce the amount of spam.
* SpamAssassin::                How to use external anti-spam tools.
* Hashcash::                    Reduce spam by burning CPU time.
* Filtering Spam Using The Spam ELisp Package::
* Filtering Spam Using Statistics with spam-stat::


File: gnus,  Node: The problem of spam,  Next: Anti-Spam Basics,  Up: Thwarting Email Spam

8.19.1 The problem of spam
--------------------------

First, some background on spam.

   If you have access to e-mail, you are familiar with spam (technically
termed UCE, Unsolicited Commercial E-mail).  Simply put, it exists
because e-mail delivery is very cheap compared to paper mail, so only a
very small percentage of people need to respond to an UCE to make it
worthwhile to the advertiser.  Ironically, one of the most common spams
is the one offering a database of e-mail addresses for further
spamming.  Senders of spam are usually called _spammers_, but terms
like _vermin_, _scum_, _sociopaths_, and _morons_ are in common use as
well.

   Spam comes from a wide variety of sources.  It is simply impossible
to dispose of all spam without discarding useful messages.  A good
example is the TMDA system, which requires senders unknown to you to
confirm themselves as legitimate senders before their e-mail can reach
you.  Without getting into the technical side of TMDA, a downside is
clearly that e-mail from legitimate sources may be discarded if those
sources can't or won't confirm themselves through the TMDA system.
Another problem with TMDA is that it requires its users to have a basic
understanding of e-mail delivery and processing.

   The simplest approach to filtering spam is filtering, at the mail
server or when you sort through incoming mail.  If you get 200 spam
messages per day from `random-address@vmadmin.com', you block
`vmadmin.com'.  If you get 200 messages about `VIAGRA', you discard all
messages with `VIAGRA' in the message.  If you get lots of spam from
Bulgaria, for example, you try to filter all mail from Bulgarian IPs.

   This, unfortunately, is a great way to discard legitimate e-mail.
The risks of blocking a whole country (Bulgaria, Norway, Nigeria, China,
etc.) or even a continent (Asia, Africa, Europe, etc.) from contacting
you should be obvious, so don't do it if you have the choice.

   In another instance, the very informative and useful RISKS digest has
been blocked by overzealous mail filters because it *contained* words
that were common in spam messages.  Nevertheless, in isolated cases,
with great care, direct filtering of mail can be useful.

   Another approach to filtering e-mail is the distributed spam
processing, for instance DCC implements such a system.  In essence, N
systems around the world agree that a machine X in Ghana, Estonia, or
California is sending out spam e-mail, and these N systems enter X or
the spam e-mail from X into a database.  The criteria for spam
detection vary--it may be the number of messages sent, the content of
the messages, and so on.  When a user of the distributed processing
system wants to find out if a message is spam, he consults one of those
N systems.

   Distributed spam processing works very well against spammers that
send a large number of messages at once, but it requires the user to
set up fairly complicated checks.  There are commercial and free
distributed spam processing systems.  Distributed spam processing has
its risks as well.  For instance legitimate e-mail senders have been
accused of sending spam, and their web sites and mailing lists have
been shut down for some time because of the incident.

   The statistical approach to spam filtering is also popular.  It is
based on a statistical analysis of previous spam messages.  Usually the
analysis is a simple word frequency count, with perhaps pairs of words
or 3-word combinations thrown into the mix.  Statistical analysis of
spam works very well in most of the cases, but it can classify
legitimate e-mail as spam in some cases.  It takes time to run the
analysis, the full message must be analyzed, and the user has to store
the database of spam analyses.  Statistical analysis on the server is
gaining popularity.  This has the advantage of letting the user Just
Read Mail, but has the disadvantage that it's harder to tell the server
that it has misclassified mail.

   Fighting spam is not easy, no matter what anyone says.  There is no
magic switch that will distinguish Viagra ads from Mom's e-mails.  Even
people are having a hard time telling spam apart from non-spam, because
spammers are actively looking to fool us into thinking they are Mom,
essentially.  Spamming is irritating, irresponsible, and idiotic
behavior from a bunch of people who think the world owes them a favor.
We hope the following sections will help you in fighting the spam
plague.


File: gnus,  Node: Anti-Spam Basics,  Next: SpamAssassin,  Prev: The problem of spam,  Up: Thwarting Email Spam

8.19.2 Anti-Spam Basics
-----------------------

One way of dealing with spam is having Gnus split out all spam into a
`spam' mail group (*note Splitting Mail::).

   First, pick one (1) valid mail address that you can be reached at,
and put it in your `From' header of all your news articles.  (I've
chosen `larsi@trym.ifi.uio.no', but for many addresses on the form
`larsi+usenet@ifi.uio.no' will be a better choice.  Ask your sysadmin
whether your sendmail installation accepts keywords in the local part
of the mail address.)

     (setq message-default-news-headers
           "From: Lars Magne Ingebrigtsen <larsi@trym.ifi.uio.no>\n")

   Then put the following split rule in `nnmail-split-fancy' (*note
Fancy Mail Splitting::):

     (...
      (to "larsi@trym.ifi.uio.no"
          (| ("subject" "re:.*" "misc")
             ("references" ".*@.*" "misc")
             "spam"))
      ...)

   This says that all mail to this address is suspect, but if it has a
`Subject' that starts with a `Re:' or has a `References' header, it's
probably ok.  All the rest goes to the `spam' group.  (This idea
probably comes from Tim Pierce.)

   In addition, many mail spammers talk directly to your SMTP server
and do not include your email address explicitly in the `To' header.
Why they do this is unknown--perhaps it's to thwart this thwarting
scheme?  In any case, this is trivial to deal with--you just put
anything not addressed to you in the `spam' group by ending your fancy
split rule in this way:

     (
      ...
      (to "larsi" "misc")
      "spam")

   In my experience, this will sort virtually everything into the right
group.  You still have to check the `spam' group from time to time to
check for legitimate mail, though.  If you feel like being a good net
citizen, you can even send off complaints to the proper authorities on
each unsolicited commercial email--at your leisure.

   This works for me.  It allows people an easy way to contact me (they
can just press `r' in the usual way), and I'm not bothered at all with
spam.  It's a win-win situation.  Forging `From' headers to point to
non-existent domains is yucky, in my opinion.

   Be careful with this approach.  Spammers are wise to it.


File: gnus,  Node: SpamAssassin,  Next: Hashcash,  Prev: Anti-Spam Basics,  Up: Thwarting Email Spam

8.19.3 SpamAssassin, Vipul's Razor, DCC, etc
--------------------------------------------

The days where the hints in the previous section were sufficient in
avoiding spam are coming to an end.  There are many tools out there
that claim to reduce the amount of spam you get.  This section could
easily become outdated fast, as new products replace old, but
fortunately most of these tools seem to have similar interfaces.  Even
though this section will use SpamAssassin as an example, it should be
easy to adapt it to most other tools.

   Note that this section does not involve the `spam.el' package, which
is discussed in the next section.  If you don't care for all the
features of `spam.el', you can make do with these simple recipes.

   If the tool you are using is not installed on the mail server, you
need to invoke it yourself.  Ideas on how to use the `:postscript' mail
source parameter (*note Mail Source Specifiers::) follow.

     (setq mail-sources
           '((file :prescript "formail -bs spamassassin < /var/mail/%u")
             (pop :user "jrl"
                  :server "pophost"
                  :postscript
                  "mv %t /tmp/foo; formail -bs spamc < /tmp/foo > %t")))

   Once you manage to process your incoming spool somehow, thus making
the mail contain e.g. a header indicating it is spam, you are ready to
filter it out.  Using normal split methods (*note Splitting Mail::):

     (setq nnmail-split-methods '(("spam"  "^X-Spam-Flag: YES")
                                  ...))

   Or using fancy split methods (*note Fancy Mail Splitting::):

     (setq nnmail-split-methods 'nnmail-split-fancy
           nnmail-split-fancy '(| ("X-Spam-Flag" "YES" "spam")
                                  ...))

   Some people might not like the idea of piping the mail through
various programs using a `:prescript' (if some program is buggy, you
might lose all mail).  If you are one of them, another solution is to
call the external tools during splitting.  Example fancy split method:

     (setq nnmail-split-fancy '(| (: kevin-spamassassin)
                                  ...))
     (defun kevin-spamassassin ()
       (save-excursion
         (save-restriction
           (widen)
           (if (eq 1 (call-process-region (point-min) (point-max)
                                          "spamc" nil nil nil "-c"))
               "spam"))))

   Note that with the nnimap backend, message bodies will not be
downloaded by default.  You need to set `nnimap-split-download-body' to
`t' to do that (*note Splitting in IMAP::).

   That is about it.  As some spam is likely to get through anyway, you
might want to have a nifty function to call when you happen to read
spam.  And here is the nifty function:

      (defun my-gnus-raze-spam ()
       "Submit SPAM to Vipul's Razor, then mark it as expirable."
       (interactive)
       (gnus-summary-show-raw-article)
       (gnus-summary-save-in-pipe "razor-report -f -d")
       (gnus-summary-mark-as-expirable 1))


File: gnus,  Node: Hashcash,  Next: Filtering Spam Using The Spam ELisp Package,  Prev: SpamAssassin,  Up: Thwarting Email Spam

8.19.4 Hashcash
---------------

A novel technique to fight spam is to require senders to do something
costly for each message they send.  This has the obvious drawback that
you cannot rely on everyone in the world using this technique, since it
is not part of the Internet standards, but it may be useful in smaller
communities.

   While the tools in the previous section work well in practice, they
work only because the tools are constantly maintained and updated as
new form of spam appears.  This means that a small percentage of spam
will always get through.  It also means that somewhere, someone needs
to read lots of spam to update these tools.  Hashcash avoids that, but
instead prefers that everyone you contact through e-mail supports the
scheme.  You can view the two approaches as pragmatic vs dogmatic.  The
approaches have their own advantages and disadvantages, but as often in
the real world, a combination of them is stronger than either one of
them separately.

   The "something costly" is to burn CPU time, more specifically to
compute a hash collision up to a certain number of bits.  The resulting
hashcash cookie is inserted in a `X-Hashcash:' header.  For more
details, and for the external application `hashcash' you need to
install to use this feature, see
`http://www.cypherspace.org/~adam/hashcash/'.  Even more information
can be found at `http://www.camram.org/'.

   If you wish to call hashcash for each message you send, say something
like:

     (require 'hashcash)
     (add-hook 'message-send-hook 'mail-add-payment)

   The `hashcash.el' library can be found in the Gnus development
contrib directory or at
`http://users.actrix.gen.nz/mycroft/hashcash.el'.

   You will need to set up some additional variables as well:

`hashcash-default-payment'
     This variable indicates the default number of bits the hash
     collision should consist of.  By default this is 0, meaning
     nothing will be done.  Suggested useful values include 17 to 29.

`hashcash-payment-alist'
     Some receivers may require you to spend burn more CPU time than the
     default.  This variable contains a list of `(ADDR AMOUNT)' cells,
     where ADDR is the receiver (email address or newsgroup) and AMOUNT
     is the number of bits in the collision that is needed.  It can
     also contain `(ADDR STRING AMOUNT)' cells, where the STRING is the
     string to use (normally the email address or newsgroup name is
     used).

`hashcash'
     Where the `hashcash' binary is installed.


   Currently there is no built in functionality in Gnus to verify
hashcash cookies, it is expected that this is performed by your hand
customized mail filtering scripts.  Improvements in this area would be
a useful contribution, however.


File: gnus,  Node: Filtering Spam Using The Spam ELisp Package,  Next: Filtering Spam Using Statistics with spam-stat,  Prev: Hashcash,  Up: Thwarting Email Spam

8.19.5 Filtering Spam Using The Spam ELisp Package
--------------------------------------------------

The idea behind `spam.el' is to have a control center for spam detection
and filtering in Gnus.  To that end, `spam.el' does two things: it
filters new mail, and it analyzes mail known to be spam or ham.  "Ham"
is the name used throughout `spam.el' to indicate non-spam messages.

   First of all, you *must* run the function `spam-initialize' to
autoload `spam.el' and to install the `spam.el' hooks.  There is one
exception: if you use the `spam-use-stat' (*note spam-stat spam
filtering::) setting, you should turn it on before `spam-initialize':

     (setq spam-use-stat t) ;; if needed
     (spam-initialize)

   So, what happens when you load `spam.el'?

   First, some hooks will get installed by `spam-initialize'.  There
are some hooks for `spam-stat' so it can save its databases, and there
are hooks so interesting things will happen when you enter and leave a
group.  More on the sequence of events later (*note Spam ELisp Package
Sequence of Events::).

   You get the following keyboard commands:

`M-d'
`M s x'
`S x'
     `gnus-summary-mark-as-spam'.

     Mark current article as spam, showing it with the `$' mark.
     Whenever you see a spam article, make sure to mark its summary line
     with `M-d' before leaving the group.  This is done automatically
     for unread articles in _spam_ groups.

`M s t'
`S t'
     `spam-bogofilter-score'.

     You must have Bogofilter installed for that command to work
     properly.

     *Note Bogofilter::.


   Also, when you load `spam.el', you will be able to customize its
variables.  Try `customize-group' on the `spam' variable group.

* Menu:

* Spam ELisp Package Sequence of Events::
* Spam ELisp Package Filtering of Incoming Mail::
* Spam ELisp Package Global Variables::
* Spam ELisp Package Configuration Examples::
* Blacklists and Whitelists::
* BBDB Whitelists::
* Gmane Spam Reporting::
* Anti-spam Hashcash Payments::
* Blackholes::
* Regular Expressions Header Matching::
* Bogofilter::
* ifile spam filtering::
* spam-stat spam filtering::
* SpamOracle::
* Extending the Spam ELisp package::


File: gnus,  Node: Spam ELisp Package Sequence of Events,  Next: Spam ELisp Package Filtering of Incoming Mail,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.1 Spam ELisp Package Sequence of Events
..............................................

You must read this section to understand how `spam.el' works.  Do not
skip, speed-read, or glance through this section.

   There are two _contact points_, if you will, between `spam.el' and
the rest of Gnus: checking new mail for spam, and leaving a group.

   Getting new mail is done in one of two ways.  You can either split
your incoming mail or you can classify new articles as ham or spam when
you enter the group.

   Splitting incoming mail is better suited to mail backends such as
`nnml' or `nnimap' where new mail appears in a single file called a
"Spool File".  See *Note Spam ELisp Package Filtering of Incoming
Mail::.

   For backends such as `nntp' there is no incoming mail spool, so an
alternate mechanism must be used.  This may also happen for backends
where the server is in charge of splitting incoming mail, and Gnus does
not do further splitting.  The `spam-autodetect' and
`spam-autodetect-methods' group parameters (accessible with `G c' and
`G p' as usual), and the corresponding variables
`gnus-spam-autodetect-methods' and `gnus-spam-autodetect-methods'
(accessible with `M-x customize-variable' as usual).

   When `spam-autodetect' is used, it hooks into the process of
entering a group.  Thus, entering a group with unseen or unread
articles becomes the substitute for checking incoming mail.  Whether
only unseen articles or all unread articles will be processed is
determined by the `spam-autodetect-recheck-messages'.  When set to `t',
unread messages will be rechecked.

   `spam-autodetect' grants the user at once more and less control of
spam filtering.  The user will have more control over each group's spam
methods, so for instance the `ding' group may have `spam-use-BBDB' as
the autodetection method, while the `suspect' group may have the
`spam-use-blacklist' and `spam-use-bogofilter' methods enabled.  Every
article detected to be spam will be marked with the spam mark `$' and
processed on exit from the group as normal spam.  The user has less
control over the _sequence_ of checks, as he might with `spam-split'.

   When the newly split mail goes into groups, or messages are
autodetected to be ham or spam, those groups must be exited (after
entering, if needed) for further spam processing to happen.  It matters
whether the group is considered a ham group, a spam group, or is
unclassified, based on its `spam-content' parameter (*note Spam ELisp
Package Global Variables::).  Spam groups have the additional
characteristic that, when entered, any unseen or unread articles
(depending on the `spam-mark-only-unseen-as-spam' variable) will be
marked as spam.  Thus, mail split into a spam group gets automatically
marked as spam when you enter the group.

   So, when you exit a group, the `spam-processors' are applied, if any
are set, and the processed mail is moved to the
`ham-process-destination' or the `spam-process-destination' depending
on the article's classification.  If the `ham-process-destination' or
the `spam-process-destination', whichever is appropriate, are `nil',
the article is left in the current group.

   If a spam is found in any group (this can be changed to only non-spam
groups with `spam-move-spam-nonspam-groups-only'), it is processed by
the active `spam-processors' (*note Spam ELisp Package Global
Variables::) when the group is exited.  Furthermore, the spam is moved
to the `spam-process-destination' (*note Spam ELisp Package Global
Variables::) for further training or deletion.  You have to load the
`gnus-registry.el' package and enable the `spam-log-to-registry'
variable if you want spam to be processed no more than once.  Thus,
spam is detected and processed everywhere, which is what most people
want.  If the `spam-process-destination' is `nil', the spam is marked as
expired, which is usually the right thing to do.

   If spam can not be moved--because of a read-only backend such as
NNTP, for example, it will be copied.

   If a ham mail is found in a ham group, as determined by the
`ham-marks' parameter, it is processed as ham by the active ham
`spam-processor' when the group is exited.  With the variables
`spam-process-ham-in-spam-groups' and
`spam-process-ham-in-nonham-groups' the behavior can be further altered
so ham found anywhere can be processed.  You have to load the
`gnus-registry.el' package and enable the `spam-log-to-registry'
variable if you want ham to be processed no more than once.  Thus, ham
is detected and processed only when necessary, which is what most
people want.  More on this in *Note Spam ELisp Package Configuration
Examples::.

   If ham can not be moved--because of a read-only backend such as
NNTP, for example, it will be copied.

   If all this seems confusing, don't worry.  Soon it will be as natural
as typing Lisp one-liners on a neural interface... err, sorry, that's
50 years in the future yet.  Just trust us, it's not so bad.


File: gnus,  Node: Spam ELisp Package Filtering of Incoming Mail,  Next: Spam ELisp Package Global Variables,  Prev: Spam ELisp Package Sequence of Events,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.2 Spam ELisp Package Filtering of Incoming Mail
......................................................

To use the `spam.el' facilities for incoming mail filtering, you must
add the following to your fancy split list `nnmail-split-fancy' or
`nnimap-split-fancy':

     (: spam-split)

   Note that the fancy split may be called `nnmail-split-fancy' or
`nnimap-split-fancy', depending on whether you use the nnmail or nnimap
back ends to retrieve your mail.

   Also, `spam-split' will not modify incoming mail in any way.

   The `spam-split' function will process incoming mail and send the
mail considered to be spam into the group name given by the variable
`spam-split-group'.  By default that group name is `spam', but you can
customize `spam-split-group'.  Make sure the contents of
`spam-split-group' are an _unqualified_ group name, for instance in an
`nnimap' server `your-server' the value `spam' will turn out to be
`nnimap+your-server:spam'.  The value `nnimap+server:spam', therefore,
is wrong and will actually give you the group
`nnimap+your-server:nnimap+server:spam' which may or may not work
depending on your server's tolerance for strange group names.

   You can also give `spam-split' a parameter, e.g.
`spam-use-regex-headers' or `"maybe-spam"'.  Why is this useful?

   Take these split rules (with `spam-use-regex-headers' and
`spam-use-blackholes' set):

      nnimap-split-fancy '(|
                           (any "ding" "ding")
                           (: spam-split)
                           ;; default mailbox
                           "mail")

   Now, the problem is that you want all ding messages to make it to the
ding folder.  But that will let obvious spam (for example, spam
detected by SpamAssassin, and `spam-use-regex-headers') through, when
it's sent to the ding list.  On the other hand, some messages to the
ding list are from a mail server in the blackhole list, so the
invocation of `spam-split' can't be before the ding rule.

   You can let SpamAssassin headers supersede ding rules, but all other
`spam-split' rules (including a second invocation of the regex-headers
check) will be after the ding rule:

     nnimap-split-fancy
           '(|
             ;; all spam detected by `spam-use-regex-headers' goes to `regex-spam'
             (: spam-split "regex-spam" 'spam-use-regex-headers)
             (any "ding" "ding")
             ;; all other spam detected by spam-split goes to `spam-split-group'
             (: spam-split)
             ;; default mailbox
             "mail")

   This lets you invoke specific `spam-split' checks depending on your
particular needs, and to target the results of those checks to a
particular spam group.  You don't have to throw all mail into all the
spam tests.  Another reason why this is nice is that messages to
mailing lists you have rules for don't have to have resource-intensive
blackhole checks performed on them.  You could also specify different
spam checks for your nnmail split vs. your nnimap split.  Go crazy.

   You should still have specific checks such as
`spam-use-regex-headers' set to `t', even if you specifically invoke
`spam-split' with the check.  The reason is that when loading
`spam.el', some conditional loading is done depending on what
`spam-use-xyz' variables you have set.  This is usually not critical,
though.

   _Note for IMAP users_

   The boolean variable `nnimap-split-download-body' needs to be set,
if you want to split based on the whole message instead of just the
headers.  By default, the nnimap back end will only retrieve the
message headers.  If you use `spam-check-bogofilter',
`spam-check-ifile', or `spam-check-stat' (the splitters that can
benefit from the full message body), you should set this variable.  It
is not set by default because it will slow IMAP down, and that is not
an appropriate decision to make on behalf of the user.

   *Note Splitting in IMAP::.

   _TODO: spam.el needs to provide a uniform way of training all the
statistical databases.  Some have that functionality built-in, others
don't._


File: gnus,  Node: Spam ELisp Package Global Variables,  Next: Spam ELisp Package Configuration Examples,  Prev: Spam ELisp Package Filtering of Incoming Mail,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.3 Spam ELisp Package Global Variables
............................................

The concepts of ham processors and spam processors are very important.
Ham processors and spam processors for a group can be set with the
`spam-process' group parameter, or the `gnus-spam-process-newsgroups'
variable.  Ham processors take mail known to be non-spam (_ham_) and
process it in some way so that later similar mail will also be
considered non-spam.  Spam processors take mail known to be spam and
process it so similar spam will be detected later.

   The format of the spam or ham processor entry used to be a symbol,
but now it is a CONS cell.  See the individual spam processor entries
for more information.

   Gnus learns from the spam you get.  You have to collect your spam in
one or more spam groups, and set or customize the variable
`spam-junk-mailgroups' as appropriate.  You can also declare groups to
contain spam by setting their group parameter `spam-contents' to
`gnus-group-spam-classification-spam', or by customizing the
corresponding variable `gnus-spam-newsgroup-contents'.  The
`spam-contents' group parameter and the `gnus-spam-newsgroup-contents'
variable can also be used to declare groups as _ham_ groups if you set
their classification to `gnus-group-spam-classification-ham'.  If
groups are not classified by means of `spam-junk-mailgroups',
`spam-contents', or `gnus-spam-newsgroup-contents', they are considered
_unclassified_.  All groups are unclassified by default.

   In spam groups, all messages are considered to be spam by default:
they get the `$' mark (`gnus-spam-mark') when you enter the group.  If
you have seen a message, had it marked as spam, then unmarked it, it
won't be marked as spam when you enter the group thereafter.  You can
disable that behavior, so all unread messages will get the `$' mark, if
you set the `spam-mark-only-unseen-as-spam' parameter to `nil'.  You
should remove the `$' mark when you are in the group summary buffer for
every message that is not spam after all.  To remove the `$' mark, you
can use `M-u' to "unread" the article, or `d' for declaring it read the
non-spam way.  When you leave a group, all spam-marked (`$') articles
are sent to a spam processor which will study them as spam samples.

   Messages may also be deleted in various other ways, and unless
`ham-marks' group parameter gets overridden below, marks `R' and `r'
for default read or explicit delete, marks `X' and `K' for automatic or
explicit kills, as well as mark `Y' for low scores, are all considered
to be associated with articles which are not spam.  This assumption
might be false, in particular if you use kill files or score files as
means for detecting genuine spam, you should then adjust the
`ham-marks' group parameter.

 -- Variable: ham-marks
     You can customize this group or topic parameter to be the list of
     marks you want to consider ham.  By default, the list contains the
     deleted, read, killed, kill-filed, and low-score marks (the idea is
     that these articles have been read, but are not spam).  It can be
     useful to also include the tick mark in the ham marks.  It is not
     recommended to make the unread mark a ham mark, because it normally
     indicates a lack of classification.  But you can do it, and we'll
     be happy for you.

 -- Variable: spam-marks
     You can customize this group or topic parameter to be the list of
     marks you want to consider spam.  By default, the list contains
     only the spam mark.  It is not recommended to change that, but you
     can if you really want to.

   When you leave _any_ group, regardless of its `spam-contents'
classification, all spam-marked articles are sent to a spam processor,
which will study these as spam samples.  If you explicit kill a lot,
you might sometimes end up with articles marked `K' which you never
saw, and which might accidentally contain spam.  Best is to make sure
that real spam is marked with `$', and nothing else.

   When you leave a _spam_ group, all spam-marked articles are marked
as expired after processing with the spam processor.  This is not done
for _unclassified_ or _ham_ groups.  Also, any *ham* articles in a spam
group will be moved to a location determined by either the
`ham-process-destination' group parameter or a match in the
`gnus-ham-process-destinations' variable, which is a list of regular
expressions matched with group names (it's easiest to customize this
variable with `M-x customize-variable <RET>
gnus-ham-process-destinations').  Each group name list is a standard
Lisp list, if you prefer to customize the variable manually.  If the
`ham-process-destination' parameter is not set, ham articles are left
in place.  If the `spam-mark-ham-unread-before-move-from-spam-group'
parameter is set, the ham articles are marked as unread before being
moved.

   If ham can not be moved--because of a read-only backend such as
NNTP, for example, it will be copied.

   Note that you can use multiples destinations per group or regular
expression!  This enables you to send your ham to a regular mail group
and to a _ham training_ group.

   When you leave a _ham_ group, all ham-marked articles are sent to a
ham processor, which will study these as non-spam samples.

   By default the variable `spam-process-ham-in-spam-groups' is `nil'.
Set it to `t' if you want ham found in spam groups to be processed.
Normally this is not done, you are expected instead to send your ham to
a ham group and process it there.

   By default the variable `spam-process-ham-in-nonham-groups' is
`nil'.  Set it to `t' if you want ham found in non-ham (spam or
unclassified) groups to be processed.  Normally this is not done, you
are expected instead to send your ham to a ham group and process it
there.

   When you leave a _ham_ or _unclassified_ group, all *spam* articles
are moved to a location determined by either the
`spam-process-destination' group parameter or a match in the
`gnus-spam-process-destinations' variable, which is a list of regular
expressions matched with group names (it's easiest to customize this
variable with `M-x customize-variable <RET>
gnus-spam-process-destinations').  Each group name list is a standard
Lisp list, if you prefer to customize the variable manually.  If the
`spam-process-destination' parameter is not set, the spam articles are
only expired.  The group name is fully qualified, meaning that if you
see `nntp:servername' before the group name in the group buffer then
you need it here as well.

   If spam can not be moved--because of a read-only backend such as
NNTP, for example, it will be copied.

   Note that you can use multiples destinations per group or regular
expression!  This enables you to send your spam to multiple _spam
training_ groups.

   The problem with processing ham and spam is that Gnus doesn't track
this processing by default.  Enable the `spam-log-to-registry' variable
so `spam.el' will use `gnus-registry.el' to track what articles have
been processed, and avoid processing articles multiple times.  Keep in
mind that if you limit the number of registry entries, this won't work
as well as it does without a limit.

   Set this variable if you want only unseen articles in spam groups to
be marked as spam.  By default, it is set.  If you set it to `nil',
unread articles will also be marked as spam.

   Set this variable if you want ham to be unmarked before it is moved
out of the spam group.  This is very useful when you use something like
the tick mark `!' to mark ham--the article will be placed in your
`ham-process-destination', unmarked as if it came fresh from the mail
server.

   When autodetecting spam, this variable tells `spam.el' whether only
unseen articles or all unread articles should be checked for spam.  It
is recommended that you leave it off.


File: gnus,  Node: Spam ELisp Package Configuration Examples,  Next: Blacklists and Whitelists,  Prev: Spam ELisp Package Global Variables,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.4 Spam ELisp Package Configuration Examples
..................................................

Ted's setup
...........

From Ted Zlatanov <tzz@lifelogs.com>.
     ;; for `gnus-registry-split-fancy-with-parent' and spam autodetection
     ;; see `gnus-registry.el' for more information
     (gnus-registry-initialize)
     (spam-initialize)

     ;; I like `C-s' for marking spam
     (define-key gnus-summary-mode-map "\C-s" 'gnus-summary-mark-as-spam)

     (setq
      spam-log-to-registry t     ; for spam autodetection
      spam-use-BBDB t
      spam-use-regex-headers t   ; catch X-Spam-Flag (SpamAssassin)
      ;; all groups with `spam' in the name contain spam
      gnus-spam-newsgroup-contents
       '(("spam" gnus-group-spam-classification-spam))
      ;; see documentation for these
      spam-move-spam-nonspam-groups-only nil
      spam-mark-only-unseen-as-spam t
      spam-mark-ham-unread-before-move-from-spam-group t
      nnimap-split-rule 'nnimap-split-fancy
      ;; understand what this does before you copy it to your own setup!
      nnimap-split-fancy '(|
                           ;; trace references to parents and put in their group
                           (: gnus-registry-split-fancy-with-parent)
                           ;; this will catch server-side SpamAssassin tags
                           (: spam-split 'spam-use-regex-headers)
                           (any "ding" "ding")
                           ;; note that spam by default will go to `spam'
                           (: spam-split)
                           ;; default mailbox
                           "mail"))

     ;; my parameters, set with `G p'

     ;; all nnml groups, and all nnimap groups except
     ;; `nnimap+mail.lifelogs.com:train' and
     ;; `nnimap+mail.lifelogs.com:spam': any spam goes to nnimap training,
     ;; because it must have been detected manually

     ((spam-process-destination . "nnimap+mail.lifelogs.com:train"))

     ;; all NNTP groups
     ;; autodetect spam with the blacklist and ham with the BBDB
     ((spam-autodetect-methods spam-use-blacklist spam-use-BBDB)
     ;; send all spam to the training group
      (spam-process-destination . "nnimap+mail.lifelogs.com:train"))

     ;; only some NNTP groups, where I want to autodetect spam
     ((spam-autodetect . t))

     ;; my nnimap `nnimap+mail.lifelogs.com:spam' group

     ;; this is a spam group
     ((spam-contents gnus-group-spam-classification-spam)

      ;; any spam (which happens when I enter for all unseen messages,
      ;; because of the `gnus-spam-newsgroup-contents' setting above), goes to
      ;; `nnimap+mail.lifelogs.com:train' unless I mark it as ham

      (spam-process-destination "nnimap+mail.lifelogs.com:train")

      ;; any ham goes to my `nnimap+mail.lifelogs.com:mail' folder, but
      ;; also to my `nnimap+mail.lifelogs.com:trainham' folder for training

      (ham-process-destination "nnimap+mail.lifelogs.com:mail"
                               "nnimap+mail.lifelogs.com:trainham")
      ;; in this group, only `!' marks are ham
      (ham-marks
       (gnus-ticked-mark))
      ;; remembers senders in the blacklist on the way out--this is
      ;; definitely not needed, it just makes me feel better
      (spam-process (gnus-group-spam-exit-processor-blacklist)))

     ;; Later, on the IMAP server I use the `train' group for training
     ;; SpamAssassin to recognize spam, and the `trainham' group fora
     ;; recognizing ham--but Gnus has nothing to do with it.

Using `spam.el' on an IMAP server with a statistical filter on the server
.........................................................................

From Reiner Steib <reiner.steib@gmx.de>.

   My provider has set up bogofilter (in combination with DCC) on the
mail server (IMAP).  Recognized spam goes to `spam.detected', the rest
goes through the normal filter rules, i.e. to `some.folder' or to
`INBOX'.  Training on false positives or negatives is done by copying
or moving the article to `training.ham' or `training.spam'
respectively.  A cron job on the server feeds those to bogofilter with
the suitable ham or spam options and deletes them from the
`training.ham' and `training.spam' folders.

   With the following entries in `gnus-parameters', `spam.el' does most
of the job for me:

        ("nnimap:spam\\.detected"
         (gnus-article-sort-functions '(gnus-article-sort-by-chars))
         (ham-process-destination "nnimap:INBOX" "nnimap:training.ham")
         (spam-contents gnus-group-spam-classification-spam))
        ("nnimap:\\(INBOX\\|other-folders\\)"
         (spam-process-destination . "nnimap:training.spam")
         (spam-contents gnus-group-spam-classification-ham))

   * The Spam folder:

     In the folder `spam.detected', I have to check for false positives
     (i.e. legitimate mails, that were wrongly judged as spam by
     bogofilter or DCC).

     Because of the `gnus-group-spam-classification-spam' entry, all
     messages are marked as spam (with `$').  When I find a false
     positive, I mark the message with some other ham mark (`ham-marks',
     *Note Spam ELisp Package Global Variables::).  On group exit, those
     messages are copied to both groups, `INBOX' (where I want to have
     the article) and `training.ham' (for training bogofilter) and
     deleted from the `spam.detected' folder.

     The `gnus-article-sort-by-chars' entry simplifies detection of
     false positives for me.  I receive lots of worms (sweN, ...), that
     all have a similar size.  Grouping them by size (i.e. chars) makes
     finding other false positives easier.  (Of course worms aren't spam
     (UCE, UBE) strictly speaking.  Anyhow, bogofilter is an excellent
     tool for filtering those unwanted mails for me.)

   * Ham folders:

     In my ham folders, I just hit `S x' (`gnus-summary-mark-as-spam')
     whenever I see an unrecognized spam mail (false negative).  On
     group exit, those messages are moved to `training.ham'.

Reporting spam articles in Gmane groups with `spam-report.el'
.............................................................

From Reiner Steib <reiner.steib@gmx.de>.

   With following entry in `gnus-parameters', `S x'
(`gnus-summary-mark-as-spam') marks articles in `gmane.*' groups as
spam and reports the to Gmane at group exit:

        ("^gmane\\."
         (spam-process (gnus-group-spam-exit-processor-report-gmane)))

   Additionally, I use `(setq spam-report-gmane-use-article-number nil)'
because I don't read the groups directly from news.gmane.org, but
through my local news server (leafnode).  I.e. the article numbers are
not the same as on news.gmane.org, thus `spam-report.el' has to check
the `X-Report-Spam' header to find the correct number.


File: gnus,  Node: Blacklists and Whitelists,  Next: BBDB Whitelists,  Prev: Spam ELisp Package Configuration Examples,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.5 Blacklists and Whitelists
..................................

 -- Variable: spam-use-blacklist
     Set this variable to `t' if you want to use blacklists when
     splitting incoming mail.  Messages whose senders are in the
     blacklist will be sent to the `spam-split-group'.  This is an
     explicit filter, meaning that it acts only on mail senders
     _declared_ to be spammers.


 -- Variable: spam-use-whitelist
     Set this variable to `t' if you want to use whitelists when
     splitting incoming mail.  Messages whose senders are not in the
     whitelist will be sent to the next spam-split rule.  This is an
     explicit filter, meaning that unless someone is in the whitelist,
     their messages are not assumed to be spam or ham.


 -- Variable: spam-use-whitelist-exclusive
     Set this variable to `t' if you want to use whitelists as an
     implicit filter, meaning that every message will be considered spam
     unless the sender is in the whitelist.  Use with care.


 -- Variable: gnus-group-spam-exit-processor-blacklist
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     spam-marked articles will be added to the blacklist.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-blacklist', it is recommended that
     you use `'(spam spam-use-blacklist)'.  Everything will work the
     same way, we promise.


 -- Variable: gnus-group-ham-exit-processor-whitelist
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     ham-marked articles in _ham_ groups will be added to the
     whitelist.  Note that this ham processor has no effect in _spam_
     or _unclassified_ groups.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-whitelist',
     it is recommended that you use `'(ham spam-use-whitelist)'.
     Everything will work the same way, we promise.


   Blacklists are lists of regular expressions matching addresses you
consider to be spam senders.  For instance, to block mail from any
sender at `vmadmin.com', you can put `vmadmin.com' in your blacklist.
You start out with an empty blacklist.  Blacklist entries use the Emacs
regular expression syntax.

   Conversely, whitelists tell Gnus what addresses are considered
legitimate.  All messages from whitelisted addresses are considered
non-spam.  Also see *Note BBDB Whitelists::.  Whitelist entries use the
Emacs regular expression syntax.

   The blacklist and whitelist file locations can be customized with the
`spam-directory' variable (`~/News/spam' by default), or the
`spam-whitelist' and `spam-blacklist' variables directly.  The
whitelist and blacklist files will by default be in the
`spam-directory' directory, named `whitelist' and `blacklist'
respectively.


File: gnus,  Node: BBDB Whitelists,  Next: Gmane Spam Reporting,  Prev: Blacklists and Whitelists,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.6 BBDB Whitelists
........................

 -- Variable: spam-use-BBDB
     Analogous to `spam-use-whitelist' (*note Blacklists and
     Whitelists::), but uses the BBDB as the source of whitelisted
     addresses, without regular expressions.  You must have the BBDB
     loaded for `spam-use-BBDB' to work properly.  Messages whose
     senders are not in the BBDB will be sent to the next spam-split
     rule.  This is an explicit filter, meaning that unless someone is
     in the BBDB, their messages are not assumed to be spam or ham.


 -- Variable: spam-use-BBDB-exclusive
     Set this variable to `t' if you want to use the BBDB as an
     implicit filter, meaning that every message will be considered spam
     unless the sender is in the BBDB.  Use with care.  Only sender
     addresses in the BBDB will be allowed through; all others will be
     classified as spammers.


 -- Variable: gnus-group-ham-exit-processor-BBDB
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the senders of
     ham-marked articles in _ham_ groups will be added to the BBDB.
     Note that this ham processor has no effect in _spam_ or
     _unclassified_ groups.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-BBDB', it
     is recommended that you use `'(ham spam-use-BBDB)'.  Everything
     will work the same way, we promise.



File: gnus,  Node: Gmane Spam Reporting,  Next: Anti-spam Hashcash Payments,  Prev: BBDB Whitelists,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.7 Gmane Spam Reporting
.............................

 -- Variable: gnus-group-spam-exit-processor-report-gmane
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the spam-marked
     articles groups will be reported to the Gmane administrators via a
     HTTP request.

     Gmane can be found at `http://gmane.org'.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-report-gmane', it is recommended
     that you use `'(spam spam-use-gmane)'.  Everything will work the
     same way, we promise.


 -- Variable: spam-report-gmane-use-article-number
     This variable is `t' by default.  Set it to `nil' if you are
     running your own news server, for instance, and the local article
     numbers don't correspond to the Gmane article numbers.  When
     `spam-report-gmane-use-article-number' is `nil', `spam-report.el'
     will use the `X-Report-Spam' header that Gmane provides.



File: gnus,  Node: Anti-spam Hashcash Payments,  Next: Blackholes,  Prev: Gmane Spam Reporting,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.8 Anti-spam Hashcash Payments
....................................

 -- Variable: spam-use-hashcash
     Similar to `spam-use-whitelist' (*note Blacklists and
     Whitelists::), but uses hashcash tokens for whitelisting messages
     instead of the sender address.  You must have the `hashcash.el'
     package loaded for `spam-use-hashcash' to work properly.  Messages
     without a hashcash payment token will be sent to the next
     spam-split rule.  This is an explicit filter, meaning that unless a
     hashcash token is found, the messages are not assumed to be spam or
     ham.



File: gnus,  Node: Blackholes,  Next: Regular Expressions Header Matching,  Prev: Anti-spam Hashcash Payments,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.9 Blackholes
...................

 -- Variable: spam-use-blackholes
     This option is disabled by default.  You can let Gnus consult the
     blackhole-type distributed spam processing systems (DCC, for
     instance) when you set this option.  The variable
     `spam-blackhole-servers' holds the list of blackhole servers Gnus
     will consult.  The current list is fairly comprehensive, but make
     sure to let us know if it contains outdated servers.

     The blackhole check uses the `dig.el' package, but you can tell
     `spam.el' to use `dns.el' instead for better performance if you
     set `spam-use-dig' to `nil'.  It is not recommended at this time
     to set `spam-use-dig' to `nil' despite the possible performance
     improvements, because some users may be unable to use it, but you
     can try it and see if it works for you.


 -- Variable: spam-blackhole-servers
     The list of servers to consult for blackhole checks.


 -- Variable: spam-blackhole-good-server-regex
     A regular expression for IPs that should not be checked against the
     blackhole server list.  When set to `nil', it has no effect.


 -- Variable: spam-use-dig
     Use the `dig.el' package instead of the `dns.el' package.  The
     default setting of `t' is recommended.


   Blackhole checks are done only on incoming mail.  There is no spam or
ham processor for blackholes.


File: gnus,  Node: Regular Expressions Header Matching,  Next: Bogofilter,  Prev: Blackholes,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.10 Regular Expressions Header Matching
.............................................

 -- Variable: spam-use-regex-headers
     This option is disabled by default.  You can let Gnus check the
     message headers against lists of regular expressions when you set
     this option.  The variables `spam-regex-headers-spam' and
     `spam-regex-headers-ham' hold the list of regular expressions.
     Gnus will check against the message headers to determine if the
     message is spam or ham, respectively.


 -- Variable: spam-regex-headers-spam
     The list of regular expressions that, when matched in the headers
     of the message, positively identify it as spam.


 -- Variable: spam-regex-headers-ham
     The list of regular expressions that, when matched in the headers
     of the message, positively identify it as ham.


   Regular expression header checks are done only on incoming mail.
There is no specific spam or ham processor for regular expressions.


File: gnus,  Node: Bogofilter,  Next: ifile spam filtering,  Prev: Regular Expressions Header Matching,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.11 Bogofilter
....................

 -- Variable: spam-use-bogofilter
     Set this variable if you want `spam-split' to use Eric Raymond's
     speedy Bogofilter.

     With a minimum of care for associating the `$' mark for spam
     articles only, Bogofilter training all gets fairly automatic.  You
     should do this until you get a few hundreds of articles in each
     category, spam or not.  The command `S t' in summary mode, either
     for debugging or for curiosity, shows the _spamicity_ score of the
     current article (between 0.0 and 1.0).

     Bogofilter determines if a message is spam based on a specific
     threshold.  That threshold can be customized, consult the
     Bogofilter documentation.

     If the `bogofilter' executable is not in your path, Bogofilter
     processing will be turned off.

     You should not enable this if you use
     `spam-use-bogofilter-headers'.


 -- Variable: spam-use-bogofilter-headers
     Set this variable if you want `spam-split' to use Eric Raymond's
     speedy Bogofilter, looking only at the message headers.  It works
     similarly to `spam-use-bogofilter', but the `X-Bogosity' header
     must be in the message already.  Normally you would do this with a
     procmail recipe or something similar; consult the Bogofilter
     installation documents for details.

     You should not enable this if you use `spam-use-bogofilter'.


 -- Variable: gnus-group-spam-exit-processor-bogofilter
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, spam-marked articles
     will be added to the Bogofilter spam database.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-bogofilter', it is recommended
     that you use `'(spam spam-use-bogofilter)'.  Everything will work
     the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-bogofilter
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the ham-marked
     articles in _ham_ groups will be added to the Bogofilter database
     of non-spam messages.  Note that this ham processor has no effect
     in _spam_ or _unclassified_ groups.

     _WARNING_

     Instead of the obsolete
     `gnus-group-ham-exit-processor-bogofilter', it is recommended that
     you use `'(ham spam-use-bogofilter)'.  Everything will work the
     same way, we promise.

 -- Variable: spam-bogofilter-database-directory
     This is the directory where Bogofilter will store its databases.
     It is not specified by default, so Bogofilter will use its own
     default database directory.


   The Bogofilter mail classifier is similar to `ifile' in intent and
purpose.  A ham and a spam processor are provided, plus the
`spam-use-bogofilter' and `spam-use-bogofilter-headers' variables to
indicate to spam-split that Bogofilter should either be used, or has
already been used on the article.  The 0.9.2.1 version of Bogofilter
was used to test this functionality.


File: gnus,  Node: ifile spam filtering,  Next: spam-stat spam filtering,  Prev: Bogofilter,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.12 ifile spam filtering
..............................

 -- Variable: spam-use-ifile
     Enable this variable if you want `spam-split' to use `ifile', a
     statistical analyzer similar to Bogofilter.


 -- Variable: spam-ifile-all-categories
     Enable this variable if you want `spam-use-ifile' to give you all
     the ifile categories, not just spam/non-spam.  If you use this,
     make sure you train ifile as described in its documentation.


 -- Variable: spam-ifile-spam-category
     This is the category of spam messages as far as ifile is concerned.
     The actual string used is irrelevant, but you probably want to
     leave the default value of `spam'.

 -- Variable: spam-ifile-database-path
     This is the filename for the ifile database.  It is not specified
     by default, so ifile will use its own default database name.


   The ifile mail classifier is similar to Bogofilter in intent and
purpose.  A ham and a spam processor are provided, plus the
`spam-use-ifile' variable to indicate to spam-split that ifile should
be used.  The 1.2.1 version of ifile was used to test this
functionality.


File: gnus,  Node: spam-stat spam filtering,  Next: SpamOracle,  Prev: ifile spam filtering,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.13 spam-stat spam filtering
..................................

*Note Filtering Spam Using Statistics with spam-stat::.

 -- Variable: spam-use-stat
     Enable this variable if you want `spam-split' to use spam-stat.el,
     an Emacs Lisp statistical analyzer.


 -- Variable: gnus-group-spam-exit-processor-stat
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the spam-marked
     articles will be added to the spam-stat database of spam messages.

     _WARNING_

     Instead of the obsolete `gnus-group-spam-exit-processor-stat', it
     is recommended that you use `'(spam spam-use-stat)'.  Everything
     will work the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-stat
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameters or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is
     added to a group's `spam-process' parameter, the ham-marked
     articles in _ham_ groups will be added to the spam-stat database
     of non-spam messages.  Note that this ham processor has no effect
     in _spam_ or _unclassified_ groups.

     _WARNING_

     Instead of the obsolete `gnus-group-ham-exit-processor-stat', it
     is recommended that you use `'(ham spam-use-stat)'.  Everything
     will work the same way, we promise.

   This enables `spam.el' to cooperate with `spam-stat.el'.
`spam-stat.el' provides an internal (Lisp-only) spam database, which
unlike ifile or Bogofilter does not require external programs.  A spam
and a ham processor, and the `spam-use-stat' variable for `spam-split'
are provided.


File: gnus,  Node: SpamOracle,  Next: Extending the Spam ELisp package,  Prev: spam-stat spam filtering,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.14 Using SpamOracle with Gnus
....................................

An easy way to filter out spam is to use SpamOracle.  SpamOracle is an
statistical mail filtering tool written by Xavier Leroy and needs to be
installed separately.

   There are several ways to use SpamOracle with Gnus.  In all cases,
your mail is piped through SpamOracle in its _mark_ mode.  SpamOracle
will then enter an `X-Spam' header indicating whether it regards the
mail as a spam mail or not.

   One possibility is to run SpamOracle as a `:prescript' from the
*Note Mail Source Specifiers::, (*note SpamAssassin::).  This method has
the advantage that the user can see the _X-Spam_ headers.

   The easiest method is to make `spam.el' (*note Filtering Spam Using
The Spam ELisp Package::) call SpamOracle.

   To enable SpamOracle usage by `spam.el', set the variable
`spam-use-spamoracle' to `t' and configure the `nnmail-split-fancy' or
`nnimap-split-fancy' as described in the section *Note Filtering Spam
Using The Spam ELisp Package::.  In this example the `INBOX' of an
nnimap server is filtered using SpamOracle.  Mails recognized as spam
mails will be moved to `spam-split-group', `Junk' in this case.  Ham
messages stay in `INBOX':

     (setq spam-use-spamoracle t
           spam-split-group "Junk"
           nnimap-split-inbox '("INBOX")
           nnimap-split-rule 'nnimap-split-fancy
           nnimap-split-fancy '(| (: spam-split) "INBOX"))

 -- Variable: spam-use-spamoracle
     Set to `t' if you want Gnus to enable spam filtering using
     SpamOracle.

 -- Variable: spam-spamoracle-binary
     Gnus uses the SpamOracle binary called `spamoracle' found in the
     user's PATH.  Using the variable `spam-spamoracle-binary', this
     can be customized.

 -- Variable: spam-spamoracle-database
     By default, SpamOracle uses the file `~/.spamoracle.db' as a
     database to store its analyses.  This is controlled by the variable
     `spam-spamoracle-database' which defaults to `nil'.  That means
     the default SpamOracle database will be used.  In case you want
     your database to live somewhere special, set
     `spam-spamoracle-database' to this path.

   SpamOracle employs a statistical algorithm to determine whether a
message is spam or ham.  In order to get good results, meaning few
false hits or misses, SpamOracle needs training.  SpamOracle learns the
characteristics of your spam mails.  Using the _add_ mode (training
mode) one has to feed good (ham) and spam mails to SpamOracle.  This
can be done by pressing `|' in the Summary buffer and pipe the mail to
a SpamOracle process or using `spam.el''s spam- and ham-processors,
which is much more convenient.  For a detailed description of spam- and
ham-processors, *Note Filtering Spam Using The Spam ELisp Package::.

 -- Variable: gnus-group-spam-exit-processor-spamoracle
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameter or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is added
     to a group's `spam-process' parameter, spam-marked articles will be
     sent to SpamOracle as spam samples.

     _WARNING_

     Instead of the obsolete
     `gnus-group-spam-exit-processor-spamoracle', it is recommended
     that you use `'(spam spam-use-spamoracle)'.  Everything will work
     the same way, we promise.

 -- Variable: gnus-group-ham-exit-processor-spamoracle
     Add this symbol to a group's `spam-process' parameter by
     customizing the group parameter or the
     `gnus-spam-process-newsgroups' variable.  When this symbol is added
     to a group's `spam-process' parameter, the ham-marked articles in
     _ham_ groups will be sent to the SpamOracle as samples of ham
     messages.  Note that this ham processor has no effect in _spam_ or
     _unclassified_ groups.

     _WARNING_

     Instead of the obsolete
     `gnus-group-ham-exit-processor-spamoracle', it is recommended that
     you use `'(ham spam-use-spamoracle)'.  Everything will work the
     same way, we promise.

   _Example:_ These are the Group Parameters of a group that has been
classified as a ham group, meaning that it should only contain ham
messages.
      ((spam-contents gnus-group-spam-classification-ham)
       (spam-process ((ham spam-use-spamoracle)
                      (spam spam-use-spamoracle))))
   For this group the `spam-use-spamoracle' is installed for both ham
and spam processing.  If the group contains spam message (e.g. because
SpamOracle has not had enough sample messages yet) and the user marks
some messages as spam messages, these messages will be processed by
SpamOracle.  The processor sends the messages to SpamOracle as new
samples for spam.


File: gnus,  Node: Extending the Spam ELisp package,  Prev: SpamOracle,  Up: Filtering Spam Using The Spam ELisp Package

8.19.5.15 Extending the Spam ELisp package
..........................................

Say you want to add a new back end called blackbox.  For filtering
incoming mail, provide the following:

  1. Code

          (defvar spam-use-blackbox nil
            "True if blackbox should be used.")

     Add
          (spam-use-blackbox   . spam-check-blackbox)
     to `spam-list-of-checks'.

     Add
          (gnus-group-ham-exit-processor-blackbox  ham spam-use-blackbox)
          (gnus-group-spam-exit-processor-blackbox spam spam-use-blackbox)

     to `spam-list-of-processors'.

     Add
          (spam-use-blackbox spam-blackbox-register-routine
                             nil
                             spam-blackbox-unregister-routine
                             nil)

     to `spam-registration-functions'.  Write the register/unregister
     routines using the bogofilter register/unregister routines as a
     start, or other restister/unregister routines more appropriate to
     Blackbox.

  2. Functionality

     Write the `spam-check-blackbox' function.  It should return `nil'
     or `spam-split-group', observing the other conventions.  See the
     existing `spam-check-*' functions for examples of what you can do,
     and stick to the template unless you fully understand the reasons
     why you aren't.

     Make sure to add `spam-use-blackbox' to
     `spam-list-of-statistical-checks' if Blackbox is a statistical
     mail analyzer that needs the full message body to operate.


   For processing spam and ham messages, provide the following:

  1. Code

     Note you don't have to provide a spam or a ham processor.  Only
     provide them if Blackbox supports spam or ham processing.

     Also, ham and spam processors are being phased out as single
     variables.  Instead the form `'(spam spam-use-blackbox)' or `'(ham
     spam-use-blackbox)' is favored.  For now, spam/ham processor
     variables are still around but they won't be for long.

          (defvar gnus-group-spam-exit-processor-blackbox "blackbox-spam"
            "The Blackbox summary exit spam processor.
          Only applicable to spam groups.")

          (defvar gnus-group-ham-exit-processor-blackbox "blackbox-ham"
            "The whitelist summary exit ham processor.
          Only applicable to non-spam (unclassified and ham) groups.")

  2. Gnus parameters

     Add
          (const :tag "Spam: Blackbox" (spam spam-use-blackbox))
          (const :tag "Ham: Blackbox"  (ham spam-use-blackbox))
     to the `spam-process' group parameter in `gnus.el'.  Make sure you
     do it twice, once for the parameter and once for the variable
     customization.

     Add
          (variable-item spam-use-blackbox)
     to the `spam-autodetect-methods' group parameter in `gnus.el'.



File: gnus,  Node: Filtering Spam Using Statistics with spam-stat,  Prev: Filtering Spam Using The Spam ELisp Package,  Up: Thwarting Email Spam

8.19.6 Filtering Spam Using Statistics with spam-stat
-----------------------------------------------------

Paul Graham has written an excellent essay about spam filtering using
statistics: A Plan for Spam (http://www.paulgraham.com/spam.html).  In
it he describes the inherent deficiency of rule-based filtering as used
by SpamAssassin, for example: Somebody has to write the rules, and
everybody else has to install these rules.  You are always late.  It
would be much better, he argues, to filter mail based on whether it
somehow resembles spam or non-spam.  One way to measure this is word
distribution.  He then goes on to describe a solution that checks
whether a new mail resembles any of your other spam mails or not.

   The basic idea is this:  Create a two collections of your mail, one
with spam, one with non-spam.  Count how often each word appears in
either collection, weight this by the total number of mails in the
collections, and store this information in a dictionary.  For every
word in a new mail, determine its probability to belong to a spam or a
non-spam mail.  Use the 15 most conspicuous words, compute the total
probability of the mail being spam.  If this probability is higher than
a certain threshold, the mail is considered to be spam.

   Gnus supports this kind of filtering.  But it needs some setting up.
First, you need two collections of your mail, one with spam, one with
non-spam.  Then you need to create a dictionary using these two
collections, and save it.  And last but not least, you need to use this
dictionary in your fancy mail splitting rules.

* Menu:

* Creating a spam-stat dictionary::
* Splitting mail using spam-stat::
* Low-level interface to the spam-stat dictionary::


File: gnus,  Node: Creating a spam-stat dictionary,  Next: Splitting mail using spam-stat,  Up: Filtering Spam Using Statistics with spam-stat

8.19.6.1 Creating a spam-stat dictionary
........................................

Before you can begin to filter spam based on statistics, you must
create these statistics based on two mail collections, one with spam,
one with non-spam.  These statistics are then stored in a dictionary
for later use.  In order for these statistics to be meaningful, you
need several hundred emails in both collections.

   Gnus currently supports only the nnml back end for automated
dictionary creation.  The nnml back end stores all mails in a
directory, one file per mail.  Use the following:

 -- Function: spam-stat-process-spam-directory
     Create spam statistics for every file in this directory.  Every
     file is treated as one spam mail.

 -- Function: spam-stat-process-non-spam-directory
     Create non-spam statistics for every file in this directory.  Every
     file is treated as one non-spam mail.

   Usually you would call `spam-stat-process-spam-directory' on a
directory such as `~/Mail/mail/spam' (this usually corresponds the the
group `nnml:mail.spam'), and you would call
`spam-stat-process-non-spam-directory' on a directory such as
`~/Mail/mail/misc' (this usually corresponds the the group
`nnml:mail.misc').

   When you are using IMAP, you won't have the mails available locally,
so that will not work.  One solution is to use the Gnus Agent to cache
the articles.  Then you can use directories such as
`"~/News/agent/nnimap/mail.yourisp.com/personal_spam"' for
`spam-stat-process-spam-directory'.  *Note Agent as Cache::.

 -- Variable: spam-stat
     This variable holds the hash-table with all the statistics--the
     dictionary we have been talking about.  For every word in either
     collection, this hash-table stores a vector describing how often
     the word appeared in spam and often it appeared in non-spam mails.

   If you want to regenerate the statistics from scratch, you need to
reset the dictionary.

 -- Function: spam-stat-reset
     Reset the `spam-stat' hash-table, deleting all the statistics.

   When you are done, you must save the dictionary.  The dictionary may
be rather large.  If you will not update the dictionary incrementally
(instead, you will recreate it once a month, for example), then you can
reduce the size of the dictionary by deleting all words that did not
appear often enough or that do not clearly belong to only spam or only
non-spam mails.

 -- Function: spam-stat-reduce-size
     Reduce the size of the dictionary.  Use this only if you do not
     want to update the dictionary incrementally.

 -- Function: spam-stat-save
     Save the dictionary.

 -- Variable: spam-stat-file
     The filename used to store the dictionary.  This defaults to
     `~/.spam-stat.el'.


File: gnus,  Node: Splitting mail using spam-stat,  Next: Low-level interface to the spam-stat dictionary,  Prev: Creating a spam-stat dictionary,  Up: Filtering Spam Using Statistics with spam-stat

8.19.6.2 Splitting mail using spam-stat
.......................................

In order to use `spam-stat' to split your mail, you need to add the
following to your `~/.gnus.el' file:

     (require 'spam-stat)
     (spam-stat-load)

   This will load the necessary Gnus code, and the dictionary you
created.

   Next, you need to adapt your fancy splitting rules:  You need to
determine how to use `spam-stat'.  The following examples are for the
nnml back end.  Using the nnimap back end works just as well.  Just use
`nnimap-split-fancy' instead of `nnmail-split-fancy'.

   In the simplest case, you only have two groups, `mail.misc' and
`mail.spam'.  The following expression says that mail is either spam or
it should go into `mail.misc'.  If it is spam, then
`spam-stat-split-fancy' will return `mail.spam'.

     (setq nnmail-split-fancy
           `(| (: spam-stat-split-fancy)
               "mail.misc"))

 -- Variable: spam-stat-split-fancy-spam-group
     The group to use for spam.  Default is `mail.spam'.

   If you also filter mail with specific subjects into other groups, use
the following expression.  Only mails not matching the regular
expression are considered potential spam.

     (setq nnmail-split-fancy
           `(| ("Subject" "\\bspam-stat\\b" "mail.emacs")
               (: spam-stat-split-fancy)
               "mail.misc"))

   If you want to filter for spam first, then you must be careful when
creating the dictionary.  Note that `spam-stat-split-fancy' must
consider both mails in `mail.emacs' and in `mail.misc' as non-spam,
therefore both should be in your collection of non-spam mails, when
creating the dictionary!

     (setq nnmail-split-fancy
           `(| (: spam-stat-split-fancy)
               ("Subject" "\\bspam-stat\\b" "mail.emacs")
               "mail.misc"))

   You can combine this with traditional filtering.  Here, we move all
HTML-only mails into the `mail.spam.filtered' group.  Note that since
`spam-stat-split-fancy' will never see them, the mails in
`mail.spam.filtered' should be neither in your collection of spam mails,
nor in your collection of non-spam mails, when creating the dictionary!

     (setq nnmail-split-fancy
           `(| ("Content-Type" "text/html" "mail.spam.filtered")
               (: spam-stat-split-fancy)
               ("Subject" "\\bspam-stat\\b" "mail.emacs")
               "mail.misc"))


File: gnus,  Node: Low-level interface to the spam-stat dictionary,  Prev: Splitting mail using spam-stat,  Up: Filtering Spam Using Statistics with spam-stat

8.19.6.3 Low-level interface to the spam-stat dictionary
........................................................

The main interface to using `spam-stat', are the following functions:

 -- Function: spam-stat-buffer-is-spam
     Called in a buffer, that buffer is considered to be a new spam
     mail.  Use this for new mail that has not been processed before.

 -- Function: spam-stat-buffer-is-no-spam
     Called in a buffer, that buffer is considered to be a new non-spam
     mail.  Use this for new mail that has not been processed before.

 -- Function: spam-stat-buffer-change-to-spam
     Called in a buffer, that buffer is no longer considered to be
     normal mail but spam.  Use this to change the status of a mail
     that has already been processed as non-spam.

 -- Function: spam-stat-buffer-change-to-non-spam
     Called in a buffer, that buffer is no longer considered to be spam
     but normal mail.  Use this to change the status of a mail that has
     already been processed as spam.

 -- Function: spam-stat-save
     Save the hash table to the file.  The filename used is stored in
     the variable `spam-stat-file'.

 -- Function: spam-stat-load
     Load the hash table from a file.  The filename used is stored in
     the variable `spam-stat-file'.

 -- Function: spam-stat-score-word
     Return the spam score for a word.

 -- Function: spam-stat-score-buffer
     Return the spam score for a buffer.

 -- Function: spam-stat-split-fancy
     Use this function for fancy mail splitting.  Add the rule `(:
     spam-stat-split-fancy)' to `nnmail-split-fancy'

   Make sure you load the dictionary before using it.  This requires the
following in your `~/.gnus.el' file:

     (require 'spam-stat)
     (spam-stat-load)

   Typical test will involve calls to the following functions:

     Reset: (setq spam-stat (make-hash-table :test 'equal))
     Learn spam: (spam-stat-process-spam-directory "~/Mail/mail/spam")
     Learn non-spam: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
     Save table: (spam-stat-save)
     File size: (nth 7 (file-attributes spam-stat-file))
     Number of words: (hash-table-count spam-stat)
     Test spam: (spam-stat-test-directory "~/Mail/mail/spam")
     Test non-spam: (spam-stat-test-directory "~/Mail/mail/misc")
     Reduce table size: (spam-stat-reduce-size)
     Save table: (spam-stat-save)
     File size: (nth 7 (file-attributes spam-stat-file))
     Number of words: (hash-table-count spam-stat)
     Test spam: (spam-stat-test-directory "~/Mail/mail/spam")
     Test non-spam: (spam-stat-test-directory "~/Mail/mail/misc")

   Here is how you would create your dictionary:

     Reset: (setq spam-stat (make-hash-table :test 'equal))
     Learn spam: (spam-stat-process-spam-directory "~/Mail/mail/spam")
     Learn non-spam: (spam-stat-process-non-spam-directory "~/Mail/mail/misc")
     Repeat for any other non-spam group you need...
     Reduce table size: (spam-stat-reduce-size)
     Save table: (spam-stat-save)


File: gnus,  Node: Other modes,  Next: Various Various,  Prev: Thwarting Email Spam,  Up: Various

8.20 Interaction with other modes
=================================

8.20.1 Dired
------------

`gnus-dired-minor-mode' provided some useful functions for dired
buffers.  It is enabled with
     (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)

`C-c C-m C-a'
     Send dired's marked files as an attachment (`gnus-dired-attach').
     You will be prompted for a message buffer.

`C-c C-m C-l'
     Visit a file according to the appropriate mailcap entry
     (`gnus-dired-find-file-mailcap').  With prefix, open file in a new
     buffer.

`C-c C-m C-p'
     Print file according to the mailcap entry (`gnus-dired-print').  If
     there is no print command, print in a PostScript image.


File: gnus,  Node: Various Various,  Prev: Other modes,  Up: Various

8.21 Various Various
====================

`gnus-home-directory'
     All Gnus file and directory variables will be initialized from this
     variable, which defaults to `~/'.

`gnus-directory'
     Most Gnus storage file and directory variables will be initialized
     from this variable, which defaults to the `SAVEDIR' environment
     variable, or `~/News/' if that variable isn't set.

     Note that Gnus is mostly loaded when the `~/.gnus.el' file is read.
     This means that other directory variables that are initialized
     from this variable won't be set properly if you set this variable
     in `~/.gnus.el'.  Set this variable in `.emacs' instead.

`gnus-default-directory'
     Not related to the above variable at all--this variable says what
     the default directory of all Gnus buffers should be.  If you issue
     commands like `C-x C-f', the prompt you'll get starts in the
     current buffer's default directory.  If this variable is `nil'
     (which is the default), the default directory will be the default
     directory of the buffer you were in when you started Gnus.

`gnus-verbose'
     This variable is an integer between zero and ten.  The higher the
     value, the more messages will be displayed.  If this variable is
     zero, Gnus will never flash any messages, if it is seven (which is
     the default), most important messages will be shown, and if it is
     ten, Gnus won't ever shut up, but will flash so many messages it
     will make your head swim.

`gnus-verbose-backends'
     This variable works the same way as `gnus-verbose', but it applies
     to the Gnus back ends instead of Gnus proper.

`nnheader-max-head-length'
     When the back ends read straight heads of articles, they all try
     to read as little as possible.  This variable (default 8192)
     specifies the absolute max length the back ends will try to read
     before giving up on finding a separator line between the head and
     the body.  If this variable is `nil', there is no upper read
     bound.  If it is `t', the back ends won't try to read the articles
     piece by piece, but read the entire articles.  This makes sense
     with some versions of `ange-ftp' or `efs'.

`nnheader-head-chop-length'
     This variable (default 2048) says how big a piece of each article
     to read when doing the operation described above.

`nnheader-file-name-translation-alist'
     This is an alist that says how to translate characters in file
     names.  For instance, if `:' is invalid as a file character in
     file names on your system (you OS/2 user you), you could say
     something like:

          (setq nnheader-file-name-translation-alist
                '((?: . ?_)))

     In fact, this is the default value for this variable on OS/2 and MS
     Windows (phooey) systems.

`gnus-hidden-properties'
     This is a list of properties to use to hide "invisible" text.  It
     is `(invisible t intangible t)' by default on most systems, which
     makes invisible text invisible and intangible.

`gnus-parse-headers-hook'
     A hook called before parsing headers.  It can be used, for
     instance, to gather statistics on the headers fetched, or perhaps
     you'd like to prune some headers.  I don't see why you'd want
     that, though.

`gnus-shell-command-separator'
     String used to separate two shell commands.  The default is `;'.

`gnus-invalid-group-regexp'
     Regexp to match "invalid" group names when querying user for a
     group name.  The default value catches some *really* invalid group
     names who could possibly mess up Gnus internally (like allowing
     `:' in a group name, which is normally used to delimit method and
     group).

     IMAP users might want to allow `/' in group names though.



File: gnus,  Node: The End,  Next: Appendices,  Prev: Various,  Up: Top

9 The End
*********

Well, that's the manual--you can get on with your life now.  Keep in
touch.  Say hello to your cats from me.

   My *ghod*--I just can't stand goodbyes.  Sniffle.

   Ol' Charles Reznikoff said it pretty well, so I leave the floor to
him:

     *Te Deum*


     Not because of victories
     I sing,
     having none,
     but for the common sunshine,
     the breeze,
     the largess of the spring.


     Not for victory
     but for the day's work done
     as well as I was able;
     not for a seat upon the dais
     but at the common table.


File: gnus,  Node: Appendices,  Next: Index,  Prev: The End,  Up: Top

10 Appendices
*************

* Menu:

* XEmacs::                      Requirements for installing under XEmacs.
* History::                     How Gnus got where it is today.
* On Writing Manuals::          Why this is not a beginner's guide.
* Terminology::                 We use really difficult, like, words here.
* Customization::               Tailoring Gnus to your needs.
* Troubleshooting::             What you might try if things do not work.
* Gnus Reference Guide::        Rilly, rilly technical stuff.
* Emacs for Heathens::          A short introduction to Emacsian terms.
* Frequently Asked Questions::  The Gnus FAQ


File: gnus,  Node: XEmacs,  Next: History,  Up: Appendices

10.1 XEmacs
===========

XEmacs is distributed as a collection of packages.  You should install
whatever packages the Gnus XEmacs package requires.  The current
requirements are `gnus', `mail-lib', `xemacs-base', `eterm',
`sh-script', `net-utils', `os-utils', `dired', `mh-e', `sieve',
`ps-print', `W3', `pgg', `mailcrypt', `ecrypto', and `sasl'.


File: gnus,  Node: History,  Next: On Writing Manuals,  Prev: XEmacs,  Up: Appendices

10.2 History
============

GNUS was written by Masanobu UMEDA.  When autumn crept up in '94, Lars
Magne Ingebrigtsen grew bored and decided to rewrite Gnus.

   If you want to investigate the person responsible for this outrage,
you can point your (feh!) web browser to `http://quimby.gnus.org/'.
This is also the primary distribution point for the new and spiffy
versions of Gnus, and is known as The Site That Destroys Newsrcs And
Drives People Mad.

   During the first extended alpha period of development, the new Gnus
was called "(ding) Gnus".  "(ding)" is, of course, short for "ding is
not Gnus", which is a total and utter lie, but who cares?  (Besides,
the "Gnus" in this abbreviation should probably be pronounced "news" as
UMEDA intended, which makes it a more appropriate name, don't you
think?)

   In any case, after spending all that energy on coming up with a new
and spunky name, we decided that the name was _too_ spunky, so we
renamed it back again to "Gnus".  But in mixed case.  "Gnus" vs.
"GNUS".  New vs. old.

* Menu:

* Gnus Versions::               What Gnus versions have been released.
* Other Gnus Versions::         Other Gnus versions that also have been released.
* Why?::                        What's the point of Gnus?
* Compatibility::               Just how compatible is Gnus with GNUS?
* Conformity::                  Gnus tries to conform to all standards.
* Emacsen::                     Gnus can be run on a few modern Emacsen.
* Gnus Development::            How Gnus is developed.
* Contributors::                Oodles of people.
* New Features::                Pointers to some of the new stuff in Gnus.


File: gnus,  Node: Gnus Versions,  Next: Other Gnus Versions,  Up: History

10.2.1 Gnus Versions
--------------------

The first "proper" release of Gnus 5 was done in November 1995 when it
was included in the Emacs 19.30 distribution (132 (ding) Gnus releases
plus 15 Gnus 5.0 releases).

   In May 1996 the next Gnus generation (aka. "September Gnus" (after 99
releases)) was released under the name "Gnus 5.2" (40 releases).

   On July 28th 1996 work on Red Gnus was begun, and it was released on
January 25th 1997 (after 84 releases) as "Gnus 5.4" (67 releases).

   On September 13th 1997, Quassia Gnus was started and lasted 37
releases.  It was released as "Gnus 5.6" on March 8th 1998 (46
releases).

   Gnus 5.6 begat Pterodactyl Gnus on August 29th 1998 and was released
as "Gnus 5.8" (after 99 releases and a CVS repository) on December 3rd
1999.

   On the 26th of October 2000, Oort Gnus was begun and was released as
Gnus 5.10 on May 1st 2003 (24 releases).

   On the January 4th 2004, No Gnus was begun.

   If you happen upon a version of Gnus that has a prefixed name -
"(ding) Gnus", "September Gnus", "Red Gnus", "Quassia Gnus",
"Pterodactyl Gnus", "Oort Gnus", "No Gnus" - don't panic.  Don't let it
know that you're frightened.  Back away.  Slowly.  Whatever you do,
don't run.  Walk away, calmly, until you're out of its reach.  Find a
proper released version of Gnus and snuggle up to that instead.


File: gnus,  Node: Other Gnus Versions,  Next: Why?,  Prev: Gnus Versions,  Up: History

10.2.2 Other Gnus Versions
--------------------------

In addition to the versions of Gnus which have had their releases
coordinated by Lars, one major development has been Semi-gnus from
Japan.  It's based on a library called SEMI, which provides MIME
capabilities.

   These Gnusae are based mainly on Gnus 5.6 and Pterodactyl Gnus.
Collectively, they are called "Semi-gnus", and different strains are
called T-gnus, ET-gnus, Nana-gnus and Chaos.  These provide powerful
MIME and multilingualization things, especially important for Japanese
users.


File: gnus,  Node: Why?,  Next: Compatibility,  Prev: Other Gnus Versions,  Up: History

10.2.3 Why?
-----------

What's the point of Gnus?

   I want to provide a "rad", "happening", "way cool" and "hep"
newsreader, that lets you do anything you can think of.  That was my
original motivation, but while working on Gnus, it has become clear to
me that this generation of newsreaders really belong in the stone age.
Newsreaders haven't developed much since the infancy of the net.  If the
volume continues to rise with the current rate of increase, all current
newsreaders will be pretty much useless.  How do you deal with
newsgroups that have thousands of new articles each day?  How do you
keep track of millions of people who post?

   Gnus offers no real solutions to these questions, but I would very
much like to see Gnus being used as a testing ground for new methods of
reading and fetching news.  Expanding on UMEDA-san's wise decision to
separate the newsreader from the back ends, Gnus now offers a simple
interface for anybody who wants to write new back ends for fetching mail
and news from different sources.  I have added hooks for customizations
everywhere I could imagine it being useful.  By doing so, I'm inviting
every one of you to explore and invent.

   May Gnus never be complete.  `C-u 100 M-x all-hail-emacs' and `C-u
100 M-x all-hail-xemacs'.


File: gnus,  Node: Compatibility,  Next: Conformity,  Prev: Why?,  Up: History

10.2.4 Compatibility
--------------------

Gnus was designed to be fully compatible with GNUS.  Almost all key
bindings have been kept.  More key bindings have been added, of course,
but only in one or two obscure cases have old bindings been changed.

   Our motto is:

                         In a cloud bones of steel.

   All commands have kept their names.  Some internal functions have
changed their names.

   The `gnus-uu' package has changed drastically.  *Note Decoding
Articles::.

   One major compatibility question is the presence of several summary
buffers.  All variables relevant while reading a group are buffer-local
to the summary buffer they belong in.  Although many important
variables have their values copied into their global counterparts
whenever a command is executed in the summary buffer, this change might
lead to incorrect values being used unless you are careful.

   All code that relies on knowledge of GNUS internals will probably
fail.  To take two examples: Sorting `gnus-newsrc-alist' (or changing
it in any way, as a matter of fact) is strictly verboten.  Gnus
maintains a hash table that points to the entries in this alist (which
speeds up many functions), and changing the alist directly will lead to
peculiar results.

   Old hilit19 code does not work at all.  In fact, you should probably
remove all hilit code from all Gnus hooks (`gnus-group-prepare-hook'
and `gnus-summary-prepare-hook').  Gnus provides various integrated
functions for highlighting.  These are faster and more accurate.  To
make life easier for everybody, Gnus will by default remove all hilit
calls from all hilit hooks.  Uncleanliness!  Away!

   Packages like `expire-kill' will no longer work.  As a matter of
fact, you should probably remove all old GNUS packages (and other code)
when you start using Gnus.  More likely than not, Gnus already does
what you have written code to make GNUS do.  (Snicker.)

   Even though old methods of doing things are still supported, only the
new methods are documented in this manual.  If you detect a new method
of doing something while reading this manual, that does not mean you
have to stop doing it the old way.

   Gnus understands all GNUS startup files.

   Overall, a casual user who hasn't written much code that depends on
GNUS internals should suffer no problems.  If problems occur, please
let me know by issuing that magic command `M-x gnus-bug'.

   If you are in the habit of sending bug reports _very_ often, you may
find the helpful help buffer annoying after a while.  If so, set
`gnus-bug-create-help-buffer' to `nil' to avoid having it pop up at you.


File: gnus,  Node: Conformity,  Next: Emacsen,  Prev: Compatibility,  Up: History

10.2.5 Conformity
-----------------

No rebels without a clue here, ma'am.  We conform to all standards known
to (wo)man.  Except for those standards and/or conventions we disagree
with, of course.

*RFC (2)822*
     There are no known breaches of this standard.

*RFC 1036*
     There are no known breaches of this standard, either.

*Son-of-RFC 1036*
     We do have some breaches to this one.

    _X-Newsreader_
    _User-Agent_
          These are considered to be "vanity headers", while I consider
          them to be consumer information.  After seeing so many badly
          formatted articles coming from `tin' and `Netscape' I know
          not to use either of those for posting articles.  I would not
          have known that if it wasn't for the `X-Newsreader' header.

*USEFOR*
     USEFOR is an IETF working group writing a successor to RFC 1036,
     based on Son-of-RFC 1036.  They have produced a number of drafts
     proposing various changes to the format of news articles.  The
     Gnus towers will look into implementing the changes when the draft
     is accepted as an RFC.

*MIME - RFC 2045-2049 etc*
     All the various MIME RFCs are supported.

*Disposition Notifications - RFC 2298*
     Message Mode is able to request notifications from the receiver.

*PGP - RFC 1991 and RFC 2440*
     RFC 1991 is the original PGP message specification, published as
     an informational RFC.  RFC 2440 was the follow-up, now called Open
     PGP, and put on the Standards Track.  Both document a non-MIME
     aware PGP format.  Gnus supports both encoding (signing and
     encryption) and decoding (verification and decryption).

*PGP/MIME - RFC 2015/3156*
     RFC 2015 (superseded by 3156 which references RFC 2440 instead of
     RFC 1991) describes the MIME-wrapping around the RF 1991/2440
     format.  Gnus supports both encoding and decoding.

*S/MIME - RFC 2633*
     RFC 2633 describes the S/MIME format.

*IMAP - RFC 1730/2060, RFC 2195, RFC 2086, RFC 2359, RFC 2595, RFC 1731*
     RFC 1730 is IMAP version 4, updated somewhat by RFC 2060 (IMAP 4
     revision 1).  RFC 2195 describes CRAM-MD5 authentication for IMAP.
     RFC 2086 describes access control lists (ACLs) for IMAP.  RFC
     2359 describes a IMAP protocol enhancement.  RFC 2595 describes
     the proper TLS integration (STARTTLS) with IMAP.  RFC 1731
     describes the GSSAPI/Kerberos4 mechanisms for IMAP.


   If you ever notice Gnus acting non-compliant with regards to the
texts mentioned above, don't hesitate to drop a note to Gnus Towers and
let us know.


File: gnus,  Node: Emacsen,  Next: Gnus Development,  Prev: Conformity,  Up: History

10.2.6 Emacsen
--------------

Gnus should work on:

   * Emacs 20.7 and up.

   * XEmacs 21.1 and up.


   This Gnus version will absolutely not work on any Emacsen older than
that.  Not reliably, at least.  Older versions of Gnus may work on older
Emacs versions.

   There are some vague differences between Gnus on the various
platforms--XEmacs features more graphics (a logo and a toolbar)--but
other than that, things should look pretty much the same under all
Emacsen.


File: gnus,  Node: Gnus Development,  Next: Contributors,  Prev: Emacsen,  Up: History

10.2.7 Gnus Development
-----------------------

Gnus is developed in a two-phased cycle.  The first phase involves much
discussion on the `ding@gnus.org' mailing list, where people propose
changes and new features, post patches and new back ends.  This phase
is called the "alpha" phase, since the Gnusae released in this phase
are "alpha releases", or (perhaps more commonly in other circles)
"snapshots".  During this phase, Gnus is assumed to be unstable and
should not be used by casual users.  Gnus alpha releases have names
like "Red Gnus" and "Quassia Gnus".

   After futzing around for 50-100 alpha releases, Gnus is declared
"frozen", and only bug fixes are applied.  Gnus loses the prefix, and
is called things like "Gnus 5.6.32" instead.  Normal people are
supposed to be able to use these, and these are mostly discussed on the
`gnu.emacs.gnus' newsgroup.

   Some variable defaults differ between alpha Gnusae and released
Gnusae.  In particular, `mail-source-delete-incoming' defaults to `nil'
in alpha Gnusae and `t' in released Gnusae.  This is to prevent lossage
of mail if an alpha release hiccups while handling the mail.

   The division of discussion between the ding mailing list and the Gnus
newsgroup is not purely based on publicity concerns.  It's true that
having people write about the horrible things that an alpha Gnus release
can do (sometimes) in a public forum may scare people off, but more
importantly, talking about new experimental features that have been
introduced may confuse casual users.  New features are frequently
introduced, fiddled with, and judged to be found wanting, and then
either discarded or totally rewritten.  People reading the mailing list
usually keep up with these rapid changes, while people on the newsgroup
can't be assumed to do so.


File: gnus,  Node: Contributors,  Next: New Features,  Prev: Gnus Development,  Up: History

10.2.8 Contributors
-------------------

The new Gnus version couldn't have been done without the help of all the
people on the (ding) mailing list.  Every day for over a year I have
gotten billions of nice bug reports from them, filling me with joy,
every single one of them.  Smooches.  The people on the list have been
tried beyond endurance, what with my "oh, that's a neat idea <type
type>, yup, I'll release it right away <ship off> no wait, that doesn't
work at all <type type>, yup, I'll ship that one off right away <ship
off> no, wait, that absolutely does not work" policy for releases.
Micro$oft--bah.  Amateurs.  I'm _much_ worse.  (Or is that "worser"?
"much worser"?  "worsest"?)

   I would like to take this opportunity to thank the Academy for...
oops, wrong show.

   * Masanobu UMEDA--the writer of the original GNUS.

   * Shenghuo Zhu--uudecode.el, mm-uu.el, rfc1843.el, webmail.el,
     nnwarchive and many, many other things connected with MIME and
     other types of en/decoding, as well as general bug fixing, new
     functionality and stuff.

   * Per Abrahamsen--custom, scoring, highlighting and SOUP code (as
     well as numerous other things).

   * Luis Fernandes--design and graphics.

   * Joe Reiss--creator of the smiley faces.

   * Justin Sheehy--the FAQ maintainer.

   * Erik Naggum--help, ideas, support, code and stuff.

   * Wes Hardaker--`gnus-picon.el' and the manual section on "picons"
     (*note Picons::).

   * Kim-Minh Kaplan--further work on the picon code.

   * Brad Miller--`gnus-gl.el' and the GroupLens manual section (*note
     GroupLens::).

   * Sudish Joseph--innumerable bug fixes.

   * Ilja Weis--`gnus-topic.el'.

   * Steven L. Baur--lots and lots and lots of bugs detections and
     fixes.

   * Vladimir Alexiev--the refcard and reference booklets.

   * Felix Lee & Jamie Zawinski--I stole some pieces from the XGnus
     distribution by Felix Lee and JWZ.

   * Scott Byer--`nnfolder.el' enhancements & rewrite.

   * Peter Mutsaers--orphan article scoring code.

   * Ken Raeburn--POP mail support.

   * Hallvard B Furuseth--various bits and pieces, especially dealing
     with .newsrc files.

   * Brian Edmonds--`gnus-bbdb.el'.

   * David Moore--rewrite of `nnvirtual.el' and many other things.

   * Kevin Davidson--came up with the name "ding", so blame him.

   * Franois Pinard--many, many interesting and thorough bug reports,
     as well as autoconf support.


   This manual was proof-read by Adrian Aichner, with Ricardo Nassif,
Mark Borges, and Jost Krieger proof-reading parts of the manual.

   The following people have contributed many patches and suggestions:

   Christopher Davis, Andrew Eskilsson, Kai Grossjohann, Kevin Greiner,
Jesper Harder, Paul Jarc, Simon Josefsson, David Kgedal, Richard Pieri,
Fabrice Popineau, Daniel Quinlan, Michael Shields, Reiner Steib, Jason
L. Tibbitts, III, Jack Vinson, Katsumi Yamaoka, and Teodor Zlatanov.

   Also thanks to the following for patches and stuff:

   Jari Aalto, Adrian Aichner, Vladimir Alexiev, Russ Allbery, Peter
Arius, Matt Armstrong, Marc Auslander, Miles Bader, Alexei V. Barantsev,
Frank Bennett, Robert Bihlmeyer, Chris Bone, Mark Borges, Mark Boyns,
Lance A. Brown, Rob Browning, Kees de Bruin, Martin Buchholz, Joe
Buehler, Kevin Buhr, Alastair Burt, Joao Cachopo, Zlatko Calusic,
Massimo Campostrini, Castor, David Charlap, Dan Christensen, Kevin
Christian, Jae-you Chung, James H. Cloos, Jr., Laura Conrad, Michael R.
Cook, Glenn Coombs, Andrew J. Cosgriff, Neil Crellin, Frank D. Cringle,
Geoffrey T. Dairiki, Andre Deparade, Ulrik Dickow, Dave Disser, Rui-Tao
Dong, Joev Dubach, Michael Welsh Duggan, Dave Edmondson, Paul Eggert,
Mark W. Eichin, Karl Eichwalder, Enami Tsugutomo, Michael Ernst, Luc
Van Eycken, Sam Falkner, Nelson Jose dos Santos Ferreira, Sigbjorn
Finne, Sven Fischer, Paul Fisher, Decklin Foster, Gary D. Foster, Paul
Franklin, Guy Geens, Arne Georg Gleditsch, David S. Goldberg,
Michelangelo Grigni, Dale Hagglund, D. Hall, Magnus Hammerin, Kenichi
Handa, Raja R. Harinath, Yoshiki Hayashi, P. E. Jareth Hein, Hisashige
Kenji, Scott Hofmann, Marc Horowitz, Gunnar Horrigmo, Richard Hoskins,
Brad Howes, Miguel de Icaza, Franois Felix Ingrand, Tatsuya Ichikawa,
Ishikawa Ichiro, Lee Iverson, Iwamuro Motonori, Rajappa Iyer, Andreas
Jaeger, Adam P. Jenkins, Randell Jesup, Fred Johansen, Gareth Jones,
Greg Klanderman, Karl Kleinpaste, Michael Klingbeil, Peter Skov Knudsen,
Shuhei Kobayashi, Petr Konecny, Koseki Yoshinori, Thor Kristoffersen,
Jens Lautenbacher, Martin Larose, Seokchan Lee, Joerg Lenneis, Carsten
Leonhardt, James LewisMoss, Christian Limpach, Markus Linnala, Dave
Love, Mike McEwan, Tonny Madsen, Shlomo Mahlab, Nat Makarevitch, Istvan
Marko, David Martin, Jason R. Mastaler, Gordon Matzigkeit, Timo
Metzemakers, Richard Mlynarik, Lantz Moore, Morioka Tomohiko, Erik
Toubro Nielsen, Hrvoje Niksic, Andy Norman, Fred Oberhauser, C. R.
Oldham, Alexandre Oliva, Ken Olstad, Masaharu Onishi, Hideki Ono,
Ettore Perazzoli, William Perry, Stephen Peters, Jens-Ulrik Holger
Petersen, Ulrich Pfeifer, Matt Pharr, Andy Piper, John McClary Prevost,
Bill Pringlemeir, Mike Pullen, Jim Radford, Colin Rafferty, Lasse
Rasinen, Lars Balker Rasmussen, Joe Reiss, Renaud Rioboo, Roland B.
Roberts, Bart Robinson, Christian von Roques, Markus Rost, Jason Rumney,
Wolfgang Rupprecht, Jay Sachs, Dewey M. Sasser, Conrad Sauerwald, Loren
Schall, Dan Schmidt, Ralph Schleicher, Philippe Schnoebelen, Andreas
Schwab, Randal L. Schwartz, Danny Siu, Matt Simmons, Paul D. Smith,
Jeff Sparkes, Toby Speight, Michael Sperber, Darren Stalder, Richard
Stallman, Greg Stark, Sam Steingold, Paul Stevenson, Jonas Steverud,
Paul Stodghill, Kiyokazu Suto, Kurt Swanson, Samuel Tardieu, Teddy,
Chuck Thompson, Tozawa Akihiko, Philippe Troin, James Troup, Trung
Tran-Duc, Jack Twilley, Aaron M. Ucko, Aki Vehtari, Didier Verna,
Vladimir Volovich, Jan Vroonhof, Stefan Waldherr, Pete Ware, Barry A.
Warsaw, Christoph Wedler, Joe Wells, Lee Willis, and Lloyd Zusman.

   For a full overview of what each person has done, the ChangeLogs
included in the Gnus alpha distributions should give ample reading
(550kB and counting).

   Apologies to everybody that I've forgotten, of which there are many,
I'm sure.

   Gee, that's quite a list of people.  I guess that must mean that
there actually are people who are using Gnus.  Who'd'a thunk it!


File: gnus,  Node: New Features,  Prev: Contributors,  Up: History

10.2.9 New Features
-------------------

* Menu:

* ding Gnus::                   New things in Gnus 5.0/5.1, the first new Gnus.
* September Gnus::              The Thing Formally Known As Gnus 5.2/5.3.
* Red Gnus::                    Third time best---Gnus 5.4/5.5.
* Quassia Gnus::                Two times two is four, or Gnus 5.6/5.7.
* Pterodactyl Gnus::            Pentad also starts with P, AKA Gnus 5.8/5.9.
* Oort Gnus::                   It's big.  It's far out.  Gnus 5.10/5.11.

   These lists are, of course, just _short_ overviews of the _most_
important new features.  No, really.  There are tons more.  Yes, we
have feeping creaturism in full effect.


File: gnus,  Node: ding Gnus,  Next: September Gnus,  Up: New Features

10.2.9.1 (ding) Gnus
....................

New features in Gnus 5.0/5.1:

   * The look of all buffers can be changed by setting format-like
     variables (*note Group Buffer Format:: and *note Summary Buffer
     Format::).

   * Local spool and several NNTP servers can be used at once (*note
     Select Methods::).

   * You can combine groups into virtual groups (*note Virtual
     Groups::).

   * You can read a number of different mail formats (*note Getting
     Mail::).  All the mail back ends implement a convenient mail
     expiry scheme (*note Expiring Mail::).

   * Gnus can use various strategies for gathering threads that have
     lost their roots (thereby gathering loose sub-threads into one
     thread) or it can go back and retrieve enough headers to build a
     complete thread (*note Customizing Threading::).

   * Killed groups can be displayed in the group buffer, and you can
     read them as well (*note Listing Groups::).

   * Gnus can do partial group updates--you do not have to retrieve the
     entire active file just to check for new articles in a few groups
     (*note The Active File::).

   * Gnus implements a sliding scale of subscribedness to groups (*note
     Group Levels::).

   * You can score articles according to any number of criteria (*note
     Scoring::).  You can even get Gnus to find out how to score
     articles for you (*note Adaptive Scoring::).

   * Gnus maintains a dribble buffer that is auto-saved the normal Emacs
     manner, so it should be difficult to lose much data on what you
     have read if your machine should go down (*note Auto Save::).

   * Gnus now has its own startup file (`~/.gnus.el') to avoid
     cluttering up the `.emacs' file.

   * You can set the process mark on both groups and articles and
     perform operations on all the marked items (*note
     Process/Prefix::).

   * You can grep through a subset of groups and create a group from the
     results (*note Kibozed Groups::).

   * You can list subsets of groups according to, well, anything (*note
     Listing Groups::).

   * You can browse foreign servers and subscribe to groups from those
     servers (*note Browse Foreign Server::).

   * Gnus can fetch articles, asynchronously, on a second connection to
     the server (*note Asynchronous Fetching::).

   * You can cache articles locally (*note Article Caching::).

   * The uudecode functions have been expanded and generalized (*note
     Decoding Articles::).

   * You can still post uuencoded articles, which was a little-known
     feature of GNUS' past (*note Uuencoding and Posting::).

   * Fetching parents (and other articles) now actually works without
     glitches (*note Finding the Parent::).

   * Gnus can fetch FAQs and group descriptions (*note Group
     Information::).

   * Digests (and other files) can be used as the basis for groups
     (*note Document Groups::).

   * Articles can be highlighted and customized (*note Customizing
     Articles::).

   * URLs and other external references can be buttonized (*note
     Article Buttons::).

   * You can do lots of strange stuff with the Gnus window & frame
     configuration (*note Window Layout::).

   * You can click on buttons instead of using the keyboard (*note
     Buttons::).



File: gnus,  Node: September Gnus,  Next: Red Gnus,  Prev: ding Gnus,  Up: New Features

10.2.9.2 September Gnus
.......................

New features in Gnus 5.2/5.3:

   * A new message composition mode is used.  All old customization
     variables for `mail-mode', `rnews-reply-mode' and `gnus-msg' are
     now obsolete.

   * Gnus is now able to generate "sparse" threads--threads where
     missing articles are represented by empty nodes (*note Customizing
     Threading::).

          (setq gnus-build-sparse-threads 'some)

   * Outgoing articles are stored on a special archive server (*note
     Archived Messages::).

   * Partial thread regeneration now happens when articles are referred.

   * Gnus can make use of GroupLens predictions (*note GroupLens::).

   * Picons (personal icons) can be displayed under XEmacs (*note
     Picons::).

   * A `trn'-like tree buffer can be displayed (*note Tree Display::).

          (setq gnus-use-trees t)

   * An `nn'-like pick-and-read minor mode is available for the summary
     buffers (*note Pick and Read::).

          (add-hook 'gnus-summary-mode-hook 'gnus-pick-mode)

   * In binary groups you can use a special binary minor mode (*note
     Binary Groups::).

   * Groups can be grouped in a folding topic hierarchy (*note Group
     Topics::).

          (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

   * Gnus can re-send and bounce mail (*note Summary Mail Commands::).

   * Groups can now have a score, and bubbling based on entry frequency
     is possible (*note Group Score::).

          (add-hook 'gnus-summary-exit-hook 'gnus-summary-bubble-group)

   * Groups can be process-marked, and commands can be performed on
     groups of groups (*note Marking Groups::).

   * Caching is possible in virtual groups.

   * `nndoc' now understands all kinds of digests, mail boxes, rnews
     news batches, ClariNet briefs collections, and just about
     everything else (*note Document Groups::).

   * Gnus has a new back end (`nnsoup') to create/read SOUP packets
     (*note SOUP::).

   * The Gnus cache is much faster.

   * Groups can be sorted according to many criteria (*note Sorting
     Groups::).

   * New group parameters have been introduced to set list-addresses and
     expiry times (*note Group Parameters::).

   * All formatting specs allow specifying faces to be used (*note
     Formatting Fonts::).

   * There are several more commands for setting/removing/acting on
     process marked articles on the `M P' submap (*note Setting Process
     Marks::).

   * The summary buffer can be limited to show parts of the available
     articles based on a wide range of criteria.  These commands have
     been bound to keys on the `/' submap (*note Limiting::).

   * Articles can be made persistent with the `*' command (*note
     Persistent Articles::).

   * All functions for hiding article elements are now toggles.

   * Article headers can be buttonized (*note Article Washing::).

   * All mail back ends support fetching articles by `Message-ID'.

   * Duplicate mail can now be treated properly (*note Duplicates::).

   * All summary mode commands are available directly from the article
     buffer (*note Article Keymap::).

   * Frames can be part of `gnus-buffer-configuration' (*note Window
     Layout::).

   * Mail can be re-scanned by a daemonic process (*note Daemons::).

   * Gnus can make use of NoCeM files to weed out spam (*note NoCeM::).

          (setq gnus-use-nocem t)

   * Groups can be made permanently visible (*note Listing Groups::).

          (setq gnus-permanently-visible-groups "^nnml:")

   * Many new hooks have been introduced to make customizing easier.

   * Gnus respects the `Mail-Copies-To' header.

   * Threads can be gathered by looking at the `References' header
     (*note Customizing Threading::).

          (setq gnus-summary-thread-gathering-function
                'gnus-gather-threads-by-references)

   * Read articles can be stored in a special backlog buffer to avoid
     refetching (*note Article Backlog::).

          (setq gnus-keep-backlog 50)

   * A clean copy of the current article is always stored in a separate
     buffer to allow easier treatment.

   * Gnus can suggest where to save articles (*note Saving Articles::).

   * Gnus doesn't have to do as much prompting when saving (*note
     Saving Articles::).

          (setq gnus-prompt-before-saving t)

   * `gnus-uu' can view decoded files asynchronously while fetching
     articles (*note Other Decode Variables::).

          (setq gnus-uu-grabbed-file-functions 'gnus-uu-grab-view)

   * Filling in the article buffer now works properly on cited text
     (*note Article Washing::).

   * Hiding cited text adds buttons to toggle hiding, and how much
     cited text to hide is now customizable (*note Article Hiding::).

          (setq gnus-cited-lines-visible 2)

   * Boring headers can be hidden (*note Article Hiding::).

   * Default scoring values can now be set from the menu bar.

   * Further syntax checking of outgoing articles have been added.



File: gnus,  Node: Red Gnus,  Next: Quassia Gnus,  Prev: September Gnus,  Up: New Features

10.2.9.3 Red Gnus
.................

New features in Gnus 5.4/5.5:

   * `nntp.el' has been totally rewritten in an asynchronous fashion.

   * Article prefetching functionality has been moved up into Gnus
     (*note Asynchronous Fetching::).

   * Scoring can now be performed with logical operators like `and',
     `or', `not', and parent redirection (*note Advanced Scoring::).

   * Article washing status can be displayed in the article mode line
     (*note Misc Article::).

   * `gnus.el' has been split into many smaller files.

   * Suppression of duplicate articles based on Message-ID can be done
     (*note Duplicate Suppression::).

          (setq gnus-suppress-duplicates t)

   * New variables for specifying what score and adapt files are to be
     considered home score and adapt files (*note Home Score File::)
     have been added.

   * `nndoc' was rewritten to be easily extendable (*note Document
     Server Internals::).

   * Groups can inherit group parameters from parent topics (*note
     Topic Parameters::).

   * Article editing has been revamped and is now actually usable.

   * Signatures can be recognized in more intelligent fashions (*note
     Article Signature::).

   * Summary pick mode has been made to look more `nn'-like.  Line
     numbers are displayed and the `.' command can be used to pick
     articles (`Pick and Read').

   * Commands for moving the `.newsrc.eld' from one server to another
     have been added (*note Changing Servers::).

   * There's a way now to specify that "uninteresting" fields be
     suppressed when generating lines in buffers (*note Advanced
     Formatting::).

   * Several commands in the group buffer can be undone with `C-M-_'
     (*note Undo::).

   * Scoring can be done on words using the new score type `w' (*note
     Score File Format::).

   * Adaptive scoring can be done on a Subject word-by-word basis
     (*note Adaptive Scoring::).

          (setq gnus-use-adaptive-scoring '(word))

   * Scores can be decayed (*note Score Decays::).

          (setq gnus-decay-scores t)

   * Scoring can be performed using a regexp on the Date header.  The
     Date is normalized to compact ISO 8601 format first (*note Score
     File Format::).

   * A new command has been added to remove all data on articles from
     the native server (*note Changing Servers::).

   * A new command for reading collections of documents (`nndoc' with
     `nnvirtual' on top) has been added--`C-M-d' (*note Really Various
     Summary Commands::).

   * Process mark sets can be pushed and popped (*note Setting Process
     Marks::).

   * A new mail-to-news back end makes it possible to post even when
     the NNTP server doesn't allow posting (*note Mail-To-News
     Gateways::).

   * A new back end for reading searches from Web search engines
     ("DejaNews", "Alta Vista", "InReference") has been added (*note
     Web Searches::).

   * Groups inside topics can now be sorted using the standard sorting
     functions, and each topic can be sorted independently (*note Topic
     Sorting::).

   * Subsets of the groups can be sorted independently (`Sorting
     Groups').

   * Cached articles can be pulled into the groups (*note Summary
     Generation Commands::).

   * Score files are now applied in a more reliable order (*note Score
     Variables::).

   * Reports on where mail messages end up can be generated (*note
     Splitting Mail::).

   * More hooks and functions have been added to remove junk from
     incoming mail before saving the mail (*note Washing Mail::).

   * Emphasized text can be properly fontisized:



File: gnus,  Node: Quassia Gnus,  Next: Pterodactyl Gnus,  Prev: Red Gnus,  Up: New Features

10.2.9.4 Quassia Gnus
.....................

New features in Gnus 5.6:

   * New functionality for using Gnus as an offline newsreader has been
     added.  A plethora of new commands and modes have been added.
     *Note Gnus Unplugged::, for the full story.

   * The `nndraft' back end has returned, but works differently than
     before.  All Message buffers are now also articles in the `nndraft'
     group, which is created automatically.

   * `gnus-alter-header-function' can now be used to alter header
     values.

   * `gnus-summary-goto-article' now accept Message-ID's.

   * A new Message command for deleting text in the body of a message
     outside the region: `C-c C-v'.

   * You can now post to component group in `nnvirtual' groups with
     `C-u C-c C-c'.

   *  `nntp-rlogin-program'--new variable to ease customization.

   * `C-u C-c C-c' in `gnus-article-edit-mode' will now inhibit
     re-highlighting of the article buffer.

   * New element in `gnus-boring-article-headers'--`long-to'.

   * `M-i' symbolic prefix command.  *Note Symbolic Prefixes::, for
     details.

   * `L' and `I' in the summary buffer now take the symbolic prefix `a'
     to add the score rule to the `all.SCORE' file.

   * `gnus-simplify-subject-functions' variable to allow greater
     control over simplification.

   * `A T'--new command for fetching the current thread.

   * `/ T'--new command for including the current thread in the limit.

   * `M-RET' is a new Message command for breaking cited text.

   * `\\1'-expressions are now valid in `nnmail-split-methods'.

   * The `custom-face-lookup' function has been removed.  If you used
     this function in your initialization files, you must rewrite them
     to use `face-spec-set' instead.

   * Canceling now uses the current select method.  Symbolic prefix `a'
     forces normal posting method.

   * New command to translate M******** sm*rtq**t*s into proper
     text--`W d'.

   * For easier debugging of `nntp', you can set `nntp-record-commands'
     to a non-`nil' value.

   * `nntp' now uses `~/.authinfo', a `.netrc'-like file, for
     controlling where and how to send AUTHINFO to NNTP servers.

   * A command for editing group parameters from the summary buffer has
     been added.

   * A history of where mails have been split is available.

   * A new article date command has been added--`article-date-iso8601'.

   * Subjects can be simplified when threading by setting
     `gnus-score-thread-simplify'.

   * A new function for citing in Message has been
     added--`message-cite-original-without-signature'.

   * `article-strip-all-blank-lines'--new article command.

   * A new Message command to kill to the end of the article has been
     added.

   * A minimum adaptive score can be specified by using the
     `gnus-adaptive-word-minimum' variable.

   * The "lapsed date" article header can be kept continually updated
     by the `gnus-start-date-timer' command.

   * Web listserv archives can be read with the `nnlistserv' back end.

   * Old dejanews archives can now be read by `nnweb'.



File: gnus,  Node: Pterodactyl Gnus,  Next: Oort Gnus,  Prev: Quassia Gnus,  Up: New Features

10.2.9.5 Pterodactyl Gnus
.........................

New features in Gnus 5.8:

   * The mail-fetching functions have changed.  See the manual for the
     many details.  In particular, all procmail fetching variables are
     gone.

     If you used procmail like in

          (setq nnmail-use-procmail t)
          (setq nnmail-spool-file 'procmail)
          (setq nnmail-procmail-directory "~/mail/incoming/")
          (setq nnmail-procmail-suffix "\\.in")

     this now has changed to

          (setq mail-sources
                '((directory :path "~/mail/incoming/"
                             :suffix ".in")))

     *Note Mail Source Specifiers::.

   * Gnus is now a MIME-capable reader.  This affects many parts of
     Gnus, and adds a slew of new commands.  See the manual for details.

   * Gnus has also been multilingualized.  This also affects too many
     parts of Gnus to summarize here, and adds many new variables.

   * `gnus-auto-select-first' can now be a function to be called to
     position point.

   * The user can now decide which extra headers should be included in
     summary buffers and NOV files.

   * `gnus-article-display-hook' has been removed.  Instead, a number
     of variables starting with `gnus-treat-' have been added.

   * The Gnus posting styles have been redone again and now works in a
     subtly different manner.

   * New web-based back ends have been added: `nnslashdot',
     `nnwarchive' and `nnultimate'.  nnweb has been revamped, again, to
     keep up with ever-changing layouts.

   * Gnus can now read IMAP mail via `nnimap'.



File: gnus,  Node: Oort Gnus,  Prev: Pterodactyl Gnus,  Up: New Features

10.2.9.6 Oort Gnus
..................

New features in Gnus 5.10:

   * `F' (`gnus-article-followup-with-original') and `R'
     (`gnus-article-reply-with-original') only yank the text in the
     region if the region is active.

   * `gnus-group-read-ephemeral-group' can be called interactively,
     using `G M'.

   * In draft groups, `e' is now bound to `gnus-draft-edit-message'.
     Use `B w' for `gnus-summary-edit-article' instead.

   * The revised Gnus FAQ is included in the manual, *Note Frequently
     Asked Questions::.

   * Upgrading from previous (stable) version if you have used Oort.

     If you have tried Oort (the unstable Gnus branch leading to this
     release) but went back to a stable version, be careful when
     upgrading to this version.  In particular, you will probably want
     to remove all `.marks' (nnml) and `.mrk' (nnfolder) files, so that
     flags are read from your `.newsrc.eld' instead of from the
     `.marks'/`.mrk' file where this release store flags.  See a later
     entry for more information about marks.  Note that downgrading
     isn't save in general.

   * Article Buttons

     More buttons for URLs, mail addresses, Message-IDs, Info links, man
     pages and Emacs or Gnus related references.  *Note Article
     Buttons::.  The variables `gnus-button-*-level' can be used to
     control the appearance of all article buttons.  *Note Article
     Button Levels::.

   * Dired integration

     `gnus-dired-minor-mode' (see *Note Other modes::) installs key
     bindings in dired buffers to send a file as an attachment, open a
     file using the appropriate mailcap entry, and print a file using
     the mailcap entry.

   * Gnus can display RSS newsfeeds as a newsgroup.  *Note RSS::.

   * Single-part yenc encoded attachments can be decoded.

   * Picons

     The picons code has been reimplemented to work in GNU Emacs--some
     of the previous options have been removed or renamed.

     Picons are small "personal icons" representing users, domain and
     newsgroups, which can be displayed in the Article buffer.  *Note
     Picons::.

   * If the new option `gnus-treat-body-boundary' is non-`nil', a
     boundary line is drawn at the end of the headers.

   * Retrieval of charters and control messages

     There are new commands for fetching newsgroup charters (`H c') and
     control messages (`H C').

   * Delayed articles

     You can delay the sending of a message with `C-c C-j' in the
     Message buffer.  The messages are delivered at specified time.
     This is useful for sending yourself reminders.  *Note Delayed
     Articles::.

   * If `auto-compression-mode' is enabled, attachments are
     automatically decompressed when activated.

   * If the new option `nnml-use-compressed-files' is non-`nil', the
     nnml back end allows compressed message files.

   * Signed article headers (X-PGP-Sig) can be verified with `W p'.

   * The Summary Buffer uses an arrow in the fringe to indicate the
     current article.  Use `(setq gnus-summary-display-arrow nil)' to
     disable it.

   * Warn about email replies to news

     Do you often find yourself replying to news by email by mistake?
     Then the new option `gnus-confirm-mail-reply-to-news' is just the
     thing for you.

   * If the new option `gnus-summary-display-while-building' is
     non-`nil', the summary buffer is shown and updated as it's being
     built.

   * The new `recent' mark `.' indicates newly arrived messages (as
     opposed to old but unread messages).

   * The new option `gnus-gcc-mark-as-read' automatically marks Gcc
     articles as read.

   * The nndoc back end now supports mailman digests and exim bounces.

   * Gnus supports RFC 2369 mailing list headers, and adds a number of
     related commands in mailing list groups.  *Note Mailing List::.

   * The Date header can be displayed in a format that can be read aloud
     in English.  *Note Article Date::.

   * The envelope sender address can be customized when using Sendmail.
     *Note Mail Variables: (message)Mail Variables.

   * diffs are automatically highlighted in groups matching
     `mm-uu-diff-groups-regexp'

   * TLS wrapper shipped with Gnus

     TLS/SSL is now supported in IMAP and NNTP via `tls.el' and GNUTLS.
     The old TLS/SSL support via (external third party) `ssl.el' and
     OpenSSL still works.

   * New `make.bat' for compiling and installing Gnus under MS Windows

     Use `make.bat' if you want to install Gnus under MS Windows, the
     first argument to the batch-program should be the directory where
     `xemacs.exe' respectively `emacs.exe' is located, iff you want to
     install Gnus after compiling it, give `make.bat' `/copy' as the
     second parameter.

     `make.bat' has been rewritten from scratch, it now features
     automatic recognition of XEmacs and GNU Emacs, generates
     `gnus-load.el', checks if errors occur while compilation and
     generation of info files and reports them at the end of the build
     process.  It now uses `makeinfo' if it is available and falls back
     to `infohack.el' otherwise.  `make.bat' should now install all
     files which are necessary to run Gnus and be generally a complete
     replacement for the `configure; make; make install' cycle used
     under Unix systems.

     The new `make.bat' makes `make-x.bat' superfluous, so it has been
     removed.

   * Support for non-ASCII domain names

     Message supports non-ASCII domain names in From:, To: and Cc: and
     will query you whether to perform encoding when you try to send a
     message.  The variable `message-use-idna' controls this.  Gnus
     will also decode non-ASCII domain names in From:, To: and Cc: when
     you view a message.  The variable `gnus-use-idna' controls this.

   * Better handling of Microsoft citation styles

     Gnus now tries to recognize the mangled header block that some
     Microsoft mailers use to indicate that the rest of the message is
     a citation, even though it is not quoted in any way.  The variable
     `gnus-cite-unsightly-citation-regexp' matches the start of these
     citations.

   * `gnus-article-skip-boring'

     If you set `gnus-article-skip-boring' to `t', then Gnus will not
     scroll down to show you a page that contains only boring text,
     which by default means cited text and signature.  You can customize
     what is skippable using `gnus-article-boring-faces'.

     This feature is especially useful if you read many articles that
     consist of a little new content at the top with a long, untrimmed
     message cited below.

   * The format spec `%C' for positioning point has changed to `%*'.

   * The new variable `gnus-parameters' can be used to set group
     parameters.

     Earlier this was done only via `G p' (or `G c'), which stored the
     parameters in `~/.newsrc.eld', but via this variable you can enjoy
     the powers of customize, and simplified backups since you set the
     variable in `~/.gnus.el' instead of `~/.newsrc.eld'.  The variable
     maps regular expressions matching group names to group parameters,
     a'la:
          (setq gnus-parameters
                '(("mail\\..*"
                   (gnus-show-threads nil)
                   (gnus-use-scoring nil))
                  ("^nnimap:\\(foo.bar\\)$"
                   (to-group . "\\1"))))

   * Smileys (`:-)', `;-)' etc) are now iconized for Emacs too.

     Put `(setq gnus-treat-display-smileys nil)' in `~/.gnus.el' to
     disable it.

   * Gnus no longer generate the Sender: header automatically.

     Earlier it was generated iff the user configurable email address
     was different from the Gnus guessed default user address.  As the
     guessing algorithm is rarely correct these days, and (more
     controversially) the only use of the Sender: header was to check
     if you are entitled to cancel/supersede news (which is now solved
     by Cancel Locks instead, see another entry), generation of the
     header has been disabled by default.  See the variables
     `message-required-headers', `message-required-news-headers', and
     `message-required-mail-headers'.

   * Features from third party `message-utils.el' added to `message.el'.

     Message now asks if you wish to remove `(was: <old subject>)' from
     subject lines (see `message-subject-trailing-was-query').  `C-c
     M-m' and `C-c M-f' inserts markers indicating included text.  `C-c
     C-f a' adds a X-No-Archive: header.  `C-c C-f x' inserts
     appropriate headers and a note in the body for cross-postings and
     followups (see the variables `message-cross-post-*').

   * References and X-Draft-From headers are no longer generated when
     you start composing messages and `message-generate-headers-first'
     is `nil'.

   * Improved anti-spam features.

     Gnus is now able to take out spam from your mail and news streams
     using a wide variety of programs and filter rules.  Among the
     supported methods are RBL blocklists, bogofilter and
     white/blacklists.  Hooks for easy use of external packages such as
     SpamAssassin and Hashcash are also new.  *Note Thwarting Email
     Spam::.

   * Easy inclusion of X-Faces headers.

   * Face headers handling.

   * In the summary buffer, the new command `/ N' inserts new messages
     and `/ o' inserts old messages.

   * Gnus decodes morse encoded messages if you press `W m'.

   * Unread count correct in nnimap groups.

     The estimated number of unread articles in the group buffer should
     now be correct for nnimap groups.  This is achieved by calling
     `nnimap-fixup-unread-after-getting-new-news' from the
     `gnus-setup-news-hook' (called on startup) and
     `gnus-after-getting-new-news-hook'. (called after getting new
     mail).  If you have modified those variables from the default, you
     may want to add `nnimap-fixup-unread-after-getting-new-news'
     again.  If you were happy with the estimate and want to save some
     (minimal) time when getting new mail, remove the function.

   * Group Carbon Copy (GCC) quoting

     To support groups that contains SPC and other weird characters,
     groups are quoted before they are placed in the Gcc: header.  This
     means variables such as `gnus-message-archive-group' should no
     longer contain quote characters to make groups containing SPC
     work.  Also, if you are using the string `nnml:foo, nnml:bar'
     (indicating Gcc into two groups) you must change it to return the
     list `("nnml:foo" "nnml:bar")', otherwise the Gcc: line will be
     quoted incorrectly.  Note that returning the string `nnml:foo,
     nnml:bar' was incorrect earlier, it just didn't generate any
     problems since it was inserted directly.

   * `~/News/overview/' not used.

     As a result of the following change, the `~/News/overview/'
     directory is not used any more.  You can safely delete the entire
     hierarchy.

   * `gnus-agent'

     The Gnus Agent has seen a major updated and is now enabled by
     default, and all nntp and nnimap servers from `gnus-select-method'
     and `gnus-secondary-select-method' are agentized by default.
     Earlier only the server in `gnus-select-method' was agentized by
     the default, and the agent was disabled by default.  When the
     agent is enabled, headers are now also retrieved from the Agent
     cache instead of the back ends when possible.  Earlier this only
     happened in the unplugged state.  You can enroll or remove servers
     with `J a' and `J r' in the server buffer.  Gnus will not download
     articles into the Agent cache, unless you instruct it to do so,
     though, by using `J u' or `J s' from the Group buffer.  You revert
     to the old behavior of having the Agent disabled with `(setq
     gnus-agent nil)'.  Note that putting `(gnus-agentize)' in
     `~/.gnus.el' is not needed any more.

   * `gnus-summary-line-format'

     The default value changed to `%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n'.
     Moreover `gnus-extra-headers', `nnmail-extra-headers' and
     `gnus-ignored-from-addresses' changed their default so that the
     users name will be replaced by the recipient's name or the group
     name posting to for NNTP groups.

   * `deuglify.el' (`gnus-article-outlook-deuglify-article')

     A new file from Raymond Scholz <rscholz@zonix.de> for deuglifying
     broken Outlook (Express) articles.

   * `(require 'gnus-load)'

     If you use a stand-alone Gnus distribution, you'd better add
     `(require 'gnus-load)' into your `~/.emacs' after adding the Gnus
     lisp directory into load-path.

     File `gnus-load.el' contains autoload commands, functions and
     variables, some of which may not be included in distributions of
     Emacsen.

   * `gnus-slave-unplugged'

     A new command which starts Gnus offline in slave mode.

   * `message-insinuate-rmail'

     Adding `(message-insinuate-rmail)' and `(setq mail-user-agent
     'gnus-user-agent)' in `.emacs' convinces Rmail to compose, reply
     and forward messages in message-mode, where you can enjoy the
     power of MML.

   * `message-minibuffer-local-map'

     The line below enables BBDB in resending a message:
          (define-key message-minibuffer-local-map [(tab)]
            'bbdb-complete-name)

   * Externalizing and deleting of attachments.

     If `gnus-gcc-externalize-attachments' or
     `message-fcc-externalize-attachments' is non-`nil', attach local
     files as external parts.

     The command `gnus-mime-save-part-and-strip' (bound to `C-o' on
     MIME buttons) saves a part and replaces the part with an external
     one.  `gnus-mime-delete-part' (bound to `d' on MIME buttons)
     removes a part.  It works only on back ends that support editing.

   * `gnus-default-charset'

     The default value is determined from the
     `current-language-environment' variable, instead of `iso-8859-1'.
     Also the `.*' item in `gnus-group-charset-alist' is removed.

   * `gnus-posting-styles'

     Add a new format of match like
          ((header "to" "larsi.*org")
           (Organization "Somewhere, Inc."))
     The old format like the lines below is obsolete, but still
     accepted.
          (header "to" "larsi.*org"
                  (Organization "Somewhere, Inc."))

   * `message-ignored-news-headers' and `message-ignored-mail-headers'

     `X-Draft-From' and `X-Gnus-Agent-Meta-Information' have been added
     into these two variables.  If you customized those, perhaps you
     need add those two headers too.

   * Gnus reads the NOV and articles in the Agent if plugged.

     If one reads an article while plugged, and the article already
     exists in the Agent, it won't get downloaded once more.  `(setq
     gnus-agent-cache nil)' reverts to the old behavior.

   * Gnus supports the "format=flowed" (RFC 2646) parameter.  On
     composing messages, it is enabled by `use-hard-newlines'.
     Decoding format=flowed was present but not documented in earlier
     versions.

   * The option `mm-fill-flowed' can be used to disable treatment of
     "format=flowed" messages.  Also, flowed text is disabled when
     sending inline PGP signed messages.  (New in Gnus 5.10.7)

   * Gnus supports the generation of RFC 2298 Disposition Notification
     requests.

     This is invoked with the `C-c M-n' key binding from message mode.

   * Gnus supports Maildir groups.

     Gnus includes a new back end `nnmaildir.el'.  *Note Maildir::.

   * Printing capabilities are enhanced.

     Gnus supports Muttprint natively with `O P' from the Summary and
     Article buffers.  Also, each individual MIME part can be printed
     using `p' on the MIME button.

   * Message supports the Importance: (RFC 2156) header.

     In the message buffer, `C-c C-f C-i' or `C-c C-u' cycles through
     the valid values.

   * Gnus supports Cancel Locks in News.

     This means a header `Cancel-Lock' is inserted in news posting.  It
     is used to determine if you wrote an article or not (for canceling
     and superseding).  Gnus generates a random password string the
     first time you post a message, and saves it in your `~/.emacs'
     using the Custom system.  While the variable is called
     `canlock-password', it is not security sensitive data.  Publishing
     your canlock string on the web will not allow anyone to be able to
     anything she could not already do.  The behavior can be changed by
     customizing `message-insert-canlock'.

   * Gnus supports server-side mail filtering using Sieve.

     Sieve rules can be added as Group Parameters for groups, and the
     complete Sieve script is generated using `D g' from the Group
     buffer, and then uploaded to the server using `C-c C-l' in the
     generated Sieve buffer.  *Note Sieve Commands::, and the new Sieve
     manual *Note Top: (sieve)Top.

   * Extended format specs.

     Format spec `%&user-date;' is added into
     `gnus-summary-line-format-alist'.  Also, user defined extended
     format specs are supported.  The extended format specs look like
     `%u&foo;', which invokes function `gnus-user-format-function-FOO'.
     Because `&' is used as the escape character, old user defined
     format `%u&' is no longer supported.

   * `/ *' (`gnus-summary-limit-include-cached') is rewritten.

     It was aliased to `Y c' (`gnus-summary-insert-cached-articles').
     The new function filters out other articles.

   * Some limiting commands accept a `C-u' prefix to negate the match.

     If `C-u' is used on subject, author or extra headers, i.e., `/ s',
     `/ a', and `/ x' (`gnus-summary-limit-to-{subject,author,extra}')
     respectively, the result will be to display all articles that do
     not match the expression.

   * Group names are treated as UTF-8 by default.

     This is supposedly what USEFOR wanted to migrate to.  See
     `gnus-group-name-charset-group-alist' and
     `gnus-group-name-charset-method-alist' for customization.

   * The nnml and nnfolder back ends store marks for each groups.

     This makes it possible to take backup of nnml/nnfolder
     servers/groups separately of `~/.newsrc.eld', while preserving
     marks.  It also makes it possible to share articles and marks
     between users (without sharing the `~/.newsrc.eld' file) within
     e.g. a department.  It works by storing the marks stored in
     `~/.newsrc.eld' in a per-group file `.marks' (for nnml) and
     `GROUPNAME.mrk' (for nnfolder, named GROUPNAME).  If the
     nnml/nnfolder is moved to another machine, Gnus will automatically
     use the `.marks' or `.mrk' file instead of the information in
     `~/.newsrc.eld'.  The new server variables `nnml-marks-is-evil' and
     `nnfolder-marks-is-evil' can be used to disable this feature.

   * The menu bar item (in Group and Summary buffer) named "Misc" has
     been renamed to "Gnus".

   * The menu bar item (in Message mode) named "MML" has been renamed
     to "Attachments".  Note that this menu also contains security
     related stuff, like signing and encryption (*note Security:
     (message)Security.).

   * `gnus-group-charset-alist' and `gnus-group-ignored-charsets-alist'.

     The regexps in these variables are compared with full group names
     instead of real group names in 5.8.  Users who customize these
     variables should change those regexps accordingly.  For example:
          ("^han\\>" euc-kr) -> ("\\(^\\|:\\)han\\>" euc-kr)

   * Gnus supports PGP (RFC 1991/2440), PGP/MIME (RFC 2015/3156) and
     S/MIME (RFC 2630-2633).

     It needs an external S/MIME and OpenPGP implementation, but no
     additional Lisp libraries.  This add several menu items to the
     Attachments menu, and `C-c RET' key bindings, when composing
     messages.  This also obsoletes `gnus-article-hide-pgp-hook'.

   * Gnus inlines external parts (message/external).

   * MML (Mime compose) prefix changed from `M-m' to `C-c C-m'.

     This change was made to avoid conflict with the standard binding of
     `back-to-indentation', which is also useful in message mode.

   * The default for `message-forward-show-mml' changed to symbol
     `best'.

     The behavior for the `best' value is to show MML (i.e., convert to
     MIME) when appropriate.  MML will not be used when forwarding
     signed or encrypted messages, as the conversion invalidate the
     digital signature.


File: gnus,  Node: On Writing Manuals,  Next: Terminology,  Prev: History,  Up: Appendices

10.3 On Writing Manuals
=======================

I guess most manuals are written after-the-fact; documenting a program
that's already there.  This is not how this manual is written.  When
implementing something, I write the manual entry for that something
straight away.  I then see that it's difficult to explain the
functionality, so I write how it's supposed to be, and then I change the
implementation.  Writing the documentation and writing the code goes
hand in hand.

   This, of course, means that this manual has no, or little, flow.  It
documents absolutely everything in Gnus, but often not where you're
looking for it.  It is a reference manual, and not a guide to how to get
started with Gnus.

   That would be a totally different book, that should be written using
the reference manual as source material.  It would look quite
differently.


File: gnus,  Node: Terminology,  Next: Customization,  Prev: On Writing Manuals,  Up: Appendices

10.4 Terminology
================

"news"
     This is what you are supposed to use this thing for--reading news.
     News is generally fetched from a nearby NNTP server, and is
     generally publicly available to everybody.  If you post news, the
     entire world is likely to read just what you have written, and
     they'll all snigger mischievously.  Behind your back.

"mail"
     Everything that's delivered to you personally is mail.  Some
     news/mail readers (like Gnus) blur the distinction between mail
     and news, but there is a difference.  Mail is private.  News is
     public.  Mailing is not posting, and replying is not following up.

"reply"
     Send a mail to the person who has written what you are reading.

"follow up"
     Post an article to the current newsgroup responding to the article
     you are reading.

"back end"
     Gnus considers mail and news to be mostly the same, really.  The
     only difference is how to access the actual articles.  News
     articles are commonly fetched via the protocol NNTP, whereas mail
     messages could be read from a file on the local disk.  The internal
     architecture of Gnus thus comprises a "front end" and a number of
     "back ends".  Internally, when you enter a group (by hitting
     <RET>, say), you thereby invoke a function in the front end in
     Gnus.  The front end then "talks" to a back end and says things
     like "Give me the list of articles in the foo group" or "Show me
     article number 4711".

     So a back end mainly defines either a protocol (the `nntp' back
     end accesses news via NNTP, the `nnimap' back end accesses mail
     via IMAP) or a file format and directory layout (the `nnspool'
     back end accesses news via the common "spool directory" format,
     the `nnml' back end access mail via a file format and directory
     layout that's quite similar).

     Gnus does not handle the underlying media, so to speak--this is all
     done by the back ends.  A back end is a collection of functions to
     access the articles.

     However, sometimes the term "back end" is also used where "server"
     would have been more appropriate.  And then there is the term
     "select method" which can mean either.  The Gnus terminology can
     be quite confusing.

"native"
     Gnus will always use one method (and back end) as the "native", or
     default, way of getting news.

"foreign"
     You can also have any number of foreign groups active at the same
     time.  These are groups that use non-native non-secondary back
     ends for getting news.

"secondary"
     Secondary back ends are somewhere half-way between being native
     and being foreign, but they mostly act like they are native.

"article"
     A message that has been posted as news.

"mail message"
     A message that has been mailed.

"message"
     A mail message or news article

"head"
     The top part of a message, where administrative information (etc.)
     is put.

"body"
     The rest of an article.  Everything not in the head is in the body.

"header"
     A line from the head of an article.

"headers"
     A collection of such lines, or a collection of heads.  Or even a
     collection of NOV lines.

"NOV"
     When Gnus enters a group, it asks the back end for the headers of
     all unread articles in the group.  Most servers support the News
     OverView format, which is more compact and much faster to read and
     parse than the normal HEAD format.

"level"
     Each group is subscribed at some "level" or other (1-9).  The ones
     that have a lower level are "more" subscribed than the groups with
     a higher level.  In fact, groups on levels 1-5 are considered
     "subscribed"; 6-7 are "unsubscribed"; 8 are "zombies"; and 9 are
     "killed".  Commands for listing groups and scanning for new
     articles will all use the numeric prefix as "working level".

"killed groups"
     No information on killed groups is stored or updated, which makes
     killed groups much easier to handle than subscribed groups.

"zombie groups"
     Just like killed groups, only slightly less dead.

"active file"
     The news server has to keep track of what articles it carries, and
     what groups exist.  All this information in stored in the active
     file, which is rather large, as you might surmise.

"bogus groups"
     A group that exists in the `.newsrc' file, but isn't known to the
     server (i.e.,  it isn't in the active file), is a _bogus group_.
     This means that the group probably doesn't exist (any more).

"activating"
     The act of asking the server for info on a group and computing the
     number of unread articles is called "activating the group".
     Un-activated groups are listed with `*' in the group buffer.

"spool"
     News servers store their articles locally in one fashion or other.
     One old-fashioned storage method is to have just one file per
     article.  That's called a "traditional spool".

"server"
     A machine one can connect to and get news (or mail) from.

"select method"
     A structure that specifies the back end, the server and the virtual
     server settings.

"virtual server"
     A named select method.  Since a select method defines all there is
     to know about connecting to a (physical) server, taking the thing
     as a whole is a virtual server.

"washing"
     Taking a buffer and running it through a filter of some sort.  The
     result will (more often than not) be cleaner and more pleasing
     than the original.

"ephemeral groups"
     Most groups store data on what articles you have read.  "Ephemeral"
     groups are groups that will have no data stored--when you exit the
     group, it'll disappear into the aether.

"solid groups"
     This is the opposite of ephemeral groups.  All groups listed in the
     group buffer are solid groups.

"sparse articles"
     These are article placeholders shown in the summary buffer when
     `gnus-build-sparse-threads' has been switched on.

"threading"
     To put responses to articles directly after the articles they
     respond to--in a hierarchical fashion.

"root"
     The first article in a thread is the root.  It is the ancestor of
     all articles in the thread.

"parent"
     An article that has responses.

"child"
     An article that responds to a different article--its parent.

"digest"
     A collection of messages in one file.  The most common digest
     format is specified by RFC 1153.

"splitting"
     The action of sorting your emails according to certain rules.
     Sometimes incorrectly called mail filtering.



File: gnus,  Node: Customization,  Next: Troubleshooting,  Prev: Terminology,  Up: Appendices

10.5 Customization
==================

All variables are properly documented elsewhere in this manual.  This
section is designed to give general pointers on how to customize Gnus
for some quite common situations.

* Menu:

* Slow/Expensive Connection::   You run a local Emacs and get the news elsewhere.
* Slow Terminal Connection::    You run a remote Emacs.
* Little Disk Space::           You feel that having large setup files is icky.
* Slow Machine::                You feel like buying a faster machine.


File: gnus,  Node: Slow/Expensive Connection,  Next: Slow Terminal Connection,  Up: Customization

10.5.1 Slow/Expensive NNTP Connection
-------------------------------------

If you run Emacs on a machine locally, and get your news from a machine
over some very thin strings, you want to cut down on the amount of data
Gnus has to get from the NNTP server.

`gnus-read-active-file'
     Set this to `nil', which will inhibit Gnus from requesting the
     entire active file from the server.  This file is often very
     large.  You also have to set `gnus-check-new-newsgroups' and
     `gnus-check-bogus-newsgroups' to `nil' to make sure that Gnus
     doesn't suddenly decide to fetch the active file anyway.

`gnus-nov-is-evil'
     This one has to be `nil'.  If not, grabbing article headers from
     the NNTP server will not be very fast.  Not all NNTP servers
     support XOVER; Gnus will detect this by itself.


File: gnus,  Node: Slow Terminal Connection,  Next: Little Disk Space,  Prev: Slow/Expensive Connection,  Up: Customization

10.5.2 Slow Terminal Connection
-------------------------------

Let's say you use your home computer for dialing up the system that runs
Emacs and Gnus.  If your modem is slow, you want to reduce (as much as
possible) the amount of data sent over the wires.

`gnus-auto-center-summary'
     Set this to `nil' to inhibit Gnus from re-centering the summary
     buffer all the time.  If it is `vertical', do only vertical
     re-centering.  If it is neither `nil' nor `vertical', do both
     horizontal and vertical recentering.

`gnus-visible-headers'
     Cut down on the headers included in the articles to the minimum.
     You can, in fact, make do without them altogether--most of the
     useful data is in the summary buffer, anyway.  Set this variable to
     `^NEVVVVER' or `From:', or whatever you feel you need.

     Use the following to enable all the available hiding features:
          (setq gnus-treat-hide-headers 'head
                gnus-treat-hide-signature t
                gnus-treat-hide-citation t)

`gnus-use-full-window'
     By setting this to `nil', you can make all the windows smaller.
     While this doesn't really cut down much generally, it means that
     you have to see smaller portions of articles before deciding that
     you didn't want to read them anyway.

`gnus-thread-hide-subtree'
     If this is non-`nil', all threads in the summary buffer will be
     hidden initially.

`gnus-updated-mode-lines'
     If this is `nil', Gnus will not put information in the buffer mode
     lines, which might save some time.


File: gnus,  Node: Little Disk Space,  Next: Slow Machine,  Prev: Slow Terminal Connection,  Up: Customization

10.5.3 Little Disk Space
------------------------

The startup files can get rather large, so you may want to cut their
sizes a bit if you are running out of space.

`gnus-save-newsrc-file'
     If this is `nil', Gnus will never save `.newsrc'--it will only
     save `.newsrc.eld'.  This means that you will not be able to use
     any other newsreaders than Gnus.  This variable is `t' by default.

`gnus-read-newsrc-file'
     If this is `nil', Gnus will never read `.newsrc'--it will only
     read `.newsrc.eld'.  This means that you will not be able to use
     any other newsreaders than Gnus.  This variable is `t' by default.

`gnus-save-killed-list'
     If this is `nil', Gnus will not save the list of dead groups.  You
     should also set `gnus-check-new-newsgroups' to `ask-server' and
     `gnus-check-bogus-newsgroups' to `nil' if you set this variable to
     `nil'.  This variable is `t' by default.



File: gnus,  Node: Slow Machine,  Prev: Little Disk Space,  Up: Customization

10.5.4 Slow Machine
-------------------

If you have a slow machine, or are just really impatient, there are a
few things you can do to make Gnus run faster.

   Set `gnus-check-new-newsgroups' and `gnus-check-bogus-newsgroups' to
`nil' to make startup faster.

   Set `gnus-show-threads', `gnus-use-cross-reference' and
`gnus-nov-is-evil' to `nil' to make entering and exiting the summary
buffer faster.


File: gnus,  Node: Troubleshooting,  Next: Gnus Reference Guide,  Prev: Customization,  Up: Appendices

10.6 Troubleshooting
====================

Gnus works _so_ well straight out of the box--I can't imagine any
problems, really.

   Ahem.

  1. Make sure your computer is switched on.

  2. Make sure that you really load the current Gnus version.  If you
     have been running GNUS, you need to exit Emacs and start it up
     again before Gnus will work.

  3. Try doing an `M-x gnus-version'.  If you get something that looks
     like `Gnus v5.10.6' you have the right files loaded.  Otherwise
     you have some old `.el' files lying around.  Delete these.

  4. Read the help group (`G h' in the group buffer) for a FAQ and a
     how-to.

  5. Gnus works on many recursive structures, and in some extreme (and
     very rare) cases Gnus may recurse down "too deeply" and Emacs will
     beep at you.  If this happens to you, set `max-lisp-eval-depth' to
     500 or something like that.

   If all else fails, report the problem as a bug.

   If you find a bug in Gnus, you can report it with the `M-x gnus-bug'
command.  `M-x set-variable RET debug-on-error RET t RET', and send me
the backtrace.  I will fix bugs, but I can only fix them if you send me
a precise description as to how to reproduce the bug.

   You really can never be too detailed in a bug report.  Always use the
`M-x gnus-bug' command when you make bug reports, even if it creates a
10Kb mail each time you use it, and even if you have sent me your
environment 500 times before.  I don't care.  I want the full info each
time.

   It is also important to remember that I have no memory whatsoever.
If you send a bug report, and I send you a reply, and then you just send
back "No, it's not! Moron!", I will have no idea what you are insulting
me about.  Always over-explain everything.  It's much easier for all of
us--if I don't have all the information I need, I will just mail you
and ask for more info, and everything takes more time.

   If the problem you're seeing is very visual, and you can't quite
explain it, copy the Emacs window to a file (with `xwd', for instance),
put it somewhere it can be reached, and include the URL of the picture
in the bug report.

   If you would like to contribute a patch to fix bugs or make
improvements, please produce the patch using `diff -u'.

   If you want to debug your problem further before reporting, possibly
in order to solve the problem yourself and send a patch, you can use
edebug.  Debugging Lisp code is documented in the Elisp manual (*note
Debugging Lisp Programs: (elisp)Debugging.).  To get you started with
edebug, consider if you discover some weird behavior when pressing `c',
the first step is to do `C-h k c' and click on the hyperlink (Emacs
only) in the documentation buffer that leads you to the function
definition, then press `M-x edebug-defun RET' with point inside that
function, return to Gnus and press `c' to invoke the code.  You will be
placed in the lisp buffer and can single step using `SPC' and evaluate
expressions using `M-:' or inspect variables using `C-h v', abort
execution with `q', and resume execution with `c' or `g'.

   Sometimes, a problem do not directly generate an elisp error but
manifests itself by causing Gnus to be very slow.  In these cases, you
can use `M-x toggle-debug-on-quit' and press `C-g' when things are
slow, and then try to analyze the backtrace (repeating the procedure
helps isolating the real problem areas).

   A fancier approach is to use the elisp profiler, ELP.  The profiler
is (or should be) fully documented elsewhere, but to get you started
there are a few steps that need to be followed.  First, instrument the
part of Gnus you are interested in for profiling, e.g. `M-x
elp-instrument-package RET gnus' or `M-x elp-instrument-package RET
message'.  Then perform the operation that is slow and press `M-x
elp-results'.  You will then see which operations that takes time, and
can debug them further.  If the entire operation takes much longer than
the time spent in the slowest function in the profiler output, you
probably profiled the wrong part of Gnus.  To reset profiling
statistics, use `M-x elp-reset-all'.  `M-x elp-restore-all' is supposed
to remove profiling, but given the complexities and dynamic code
generation in Gnus, it might not always work perfectly.

   If you just need help, you are better off asking on
`gnu.emacs.gnus'.  I'm not very helpful.  You can also ask on the ding
mailing list <ding@gnus.org>.  Write to <ding-request@gnus.org> to
subscribe.


File: gnus,  Node: Gnus Reference Guide,  Next: Emacs for Heathens,  Prev: Troubleshooting,  Up: Appendices

10.7 Gnus Reference Guide
=========================

It is my hope that other people will figure out smart stuff that Gnus
can do, and that other people will write those smart things as well.  To
facilitate that I thought it would be a good idea to describe the inner
workings of Gnus.  And some of the not-so-inner workings, while I'm at
it.

   You can never expect the internals of a program not to change, but I
will be defining (in some details) the interface between Gnus and its
back ends (this is written in stone), the format of the score files
(ditto), data structures (some are less likely to change than others)
and general methods of operation.

* Menu:

* Gnus Utility Functions::      Common functions and variable to use.
* Back End Interface::          How Gnus communicates with the servers.
* Score File Syntax::           A BNF definition of the score file standard.
* Headers::                     How Gnus stores headers internally.
* Ranges::                      A handy format for storing mucho numbers.
* Group Info::                  The group info format.
* Extended Interactive::        Symbolic prefixes and stuff.
* Emacs/XEmacs Code::           Gnus can be run under all modern Emacsen.
* Various File Formats::        Formats of files that Gnus use.


File: gnus,  Node: Gnus Utility Functions,  Next: Back End Interface,  Up: Gnus Reference Guide

10.7.1 Gnus Utility Functions
-----------------------------

When writing small functions to be run from hooks (and stuff), it's
vital to have access to the Gnus internal functions and variables.
Below is a list of the most common ones.

`gnus-newsgroup-name'
     This variable holds the name of the current newsgroup.

`gnus-find-method-for-group'
     A function that returns the select method for GROUP.

`gnus-group-real-name'
     Takes a full (prefixed) Gnus group name, and returns the unprefixed
     name.

`gnus-group-prefixed-name'
     Takes an unprefixed group name and a select method, and returns
     the full (prefixed) Gnus group name.

`gnus-get-info'
     Returns the group info list for GROUP.

`gnus-group-unread'
     The number of unread articles in GROUP, or `t' if that is unknown.

`gnus-active'
     The active entry for GROUP.

`gnus-set-active'
     Set the active entry for GROUP.

`gnus-add-current-to-buffer-list'
     Adds the current buffer to the list of buffers to be killed on Gnus
     exit.

`gnus-continuum-version'
     Takes a Gnus version string as a parameter and returns a floating
     point number.  Earlier versions will always get a lower number
     than later versions.

`gnus-group-read-only-p'
     Says whether GROUP is read-only or not.

`gnus-news-group-p'
     Says whether GROUP came from a news back end.

`gnus-ephemeral-group-p'
     Says whether GROUP is ephemeral or not.

`gnus-server-to-method'
     Returns the select method corresponding to SERVER.

`gnus-server-equal'
     Says whether two virtual servers are equal.

`gnus-group-native-p'
     Says whether GROUP is native or not.

`gnus-group-secondary-p'
     Says whether GROUP is secondary or not.

`gnus-group-foreign-p'
     Says whether GROUP is foreign or not.

`gnus-group-find-parameter'
     Returns the parameter list of GROUP.  If given a second parameter,
     returns the value of that parameter for GROUP.

`gnus-group-set-parameter'
     Takes three parameters; GROUP, PARAMETER and VALUE.

`gnus-narrow-to-body'
     Narrows the current buffer to the body of the article.

`gnus-check-backend-function'
     Takes two parameters, FUNCTION and GROUP.  If the back end GROUP
     comes from supports FUNCTION, return non-`nil'.

          (gnus-check-backend-function "request-scan" "nnml:misc")
          => t

`gnus-read-method'
     Prompts the user for a select method.



File: gnus,  Node: Back End Interface,  Next: Score File Syntax,  Prev: Gnus Utility Functions,  Up: Gnus Reference Guide

10.7.2 Back End Interface
-------------------------

Gnus doesn't know anything about NNTP, spools, mail or virtual groups.
It only knows how to talk to "virtual servers".  A virtual server is a
"back end" and some "back end variables".  As examples of the first, we
have `nntp', `nnspool' and `nnmbox'.  As examples of the latter we have
`nntp-port-number' and `nnmbox-directory'.

   When Gnus asks for information from a back end--say `nntp'--on
something, it will normally include a virtual server name in the
function parameters.  (If not, the back end should use the "current"
virtual server.)  For instance, `nntp-request-list' takes a virtual
server as its only (optional) parameter.  If this virtual server hasn't
been opened, the function should fail.

   Note that a virtual server name has no relation to some physical
server name.  Take this example:

     (nntp "odd-one"
           (nntp-address "ifi.uio.no")
           (nntp-port-number 4324))

   Here the virtual server name is `odd-one' while the name of the
physical server is `ifi.uio.no'.

   The back ends should be able to switch between several virtual
servers.  The standard back ends implement this by keeping an alist of
virtual server environments that they pull down/push up when needed.

   There are two groups of interface functions: "required functions",
which must be present, and "optional functions", which Gnus will always
check for presence before attempting to call 'em.

   All these functions are expected to return data in the buffer
`nntp-server-buffer' (` *nntpd*'), which is somewhat unfortunately
named, but we'll have to live with it.  When I talk about "resulting
data", I always refer to the data in that buffer.  When I talk about
"return value", I talk about the function value returned by the
function call.  Functions that fail should return `nil' as the return
value.

   Some back ends could be said to be "server-forming" back ends, and
some might be said not to be.  The latter are back ends that generally
only operate on one group at a time, and have no concept of "server"
--they have a group, and they deliver info on that group and nothing
more.

   Gnus identifies each message by way of group name and article
number.  A few remarks about these article numbers might be useful.
First of all, the numbers are positive integers.  Secondly, it is
normally not possible for later articles to "re-use" older article
numbers without confusing Gnus.  That is, if a group has ever contained
a message numbered 42, then no other message may get that number, or
Gnus will get mightily confused.(1) Third, article numbers must be
assigned in order of arrival in the group; this is not necessarily the
same as the date of the message.

   The previous paragraph already mentions all the "hard" restrictions
that article numbers must fulfill.  But it seems that it might be
useful to assign _consecutive_ article numbers, for Gnus gets quite
confused if there are holes in the article numbering sequence.
However, due to the "no-reuse" restriction, holes cannot be avoided
altogether.  It's also useful for the article numbers to start at 1 to
avoid running out of numbers as long as possible.

   Note that by convention, back ends are named `nnsomething', but Gnus
also comes with some `nnnotbackends', such as `nnheader.el',
`nnmail.el' and `nnoo.el'.

   In the examples and definitions I will refer to the imaginary back
end `nnchoke'.

* Menu:

* Required Back End Functions::  Functions that must be implemented.
* Optional Back End Functions::  Functions that need not be implemented.
* Error Messaging::             How to get messages and report errors.
* Writing New Back Ends::       Extending old back ends.
* Hooking New Back Ends Into Gnus::  What has to be done on the Gnus end.
* Mail-like Back Ends::         Some tips on mail back ends.

   ---------- Footnotes ----------

   (1) See the function `nnchoke-request-update-info', *Note Optional
Back End Functions::.

